/**
 * @wharfkit/wallet-plugin-cloudwallet v0.4.1
 * https://github.com/wharfkit/wallet-plugin-cloudwallet
 *
 * @license
 * Copyright (c) 2023 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1.  Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 * 2.  Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 * 3.  Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
import { Struct, Name, UInt32, Asset, AbstractWalletPlugin, WalletPluginMetadata, cancelable, PermissionLevel, Serializer, Transaction, SigningRequest } from '@wharfkit/session';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// ABI Definitions to decode data
let Buyrambytes = class Buyrambytes extends Struct {
};
__decorate([
    Struct.field(Name)
], Buyrambytes.prototype, "payer", void 0);
__decorate([
    Struct.field(Name)
], Buyrambytes.prototype, "receiver", void 0);
__decorate([
    Struct.field(UInt32)
], Buyrambytes.prototype, "bytes", void 0);
Buyrambytes = __decorate([
    Struct.type('buyrambytes')
], Buyrambytes);
let Transfer = class Transfer extends Struct {
};
__decorate([
    Struct.field(Name)
], Transfer.prototype, "from", void 0);
__decorate([
    Struct.field(Name)
], Transfer.prototype, "to", void 0);
__decorate([
    Struct.field(Asset)
], Transfer.prototype, "quantity", void 0);
__decorate([
    Struct.field('string')
], Transfer.prototype, "memo", void 0);
Transfer = __decorate([
    Struct.type('transfer')
], Transfer);

function validateModifications(original, modified) {
    // Ensure all the original actions exist within the modified transaction
    const originalsExist = original.actions.every((action) => modified.actions.some((modifiedAction) => action.equals(modifiedAction)));
    if (!originalsExist) {
        throw new Error('The modified transaction does not contain all the original actions.');
    }
    // Find all new actions added to this transaction
    const newActions = modified.actions.filter((action) => {
        return !original.actions.some((originalAction) => action.equals(originalAction));
    });
    // Iterate and validate each new action
    for (const newAction of newActions) {
        // Determine if a new action has the authorization of the original actor
        const authByUser = newAction.authorization.find((auth) => {
            return auth.actor === original.actions[0].authorization[0].actor;
        });
        if (authByUser) {
            // Ensure if a transaction fee is being paid by the user, it's going to the correct account
            const isTokenTransfer = newAction.account.equals('eosio.token') && newAction.name.equals('transfer');
            if (isTokenTransfer) {
                const data = Transfer.from(newAction.data);
                if (data.to.equals('txfee.wam') && data.memo.startsWith('WAX fee for')) {
                    continue;
                }
            }
            // Ensure if a RAM purchase is occurring during a modification, it's going to the user
            const isRAMPurchase = newAction.account.equals('eosio') && newAction.name.equals('buyrambytes');
            if (isRAMPurchase) {
                const data = Buyrambytes.from(newAction.data);
                if (data.receiver.equals(original.actions[0].authorization[0].actor)) {
                    continue;
                }
            }
            // If not passing the above rules, throw an error
            throw new Error('The modified transaction contains one or more actions that are not allowed.');
        }
    }
}
// Create and return an interval that checks whether or not the window has been closed
function registerCloseListener(t, popup, reject) {
    const closeListener = setInterval(() => {
        if (popup.closed) {
            clearInterval(closeListener);
            reject(t('error.closed', {
                default: 'The Cloud Wallet was closed before the request was completed',
            }));
        }
    }, 500);
    return closeListener;
}
// Retrieve current time
function getCurrentTime() {
    return Math.floor(new Date().getTime());
}
// Ensure the MessageEvent returned from the popup is valid
function isValidEvent(event, url, window) {
    const eventOrigin = new URL(event.origin);
    const validOrigin = eventOrigin.origin === url.origin;
    const validSource = event.source === window;
    const validObject = typeof event.data === 'object';
    if (!validObject || !validOrigin || !validSource) {
        return false;
    }
    return true;
}

async function autoLogin(t, urlString) {
    // TODO: Figure out what temp accounts are
    //
    // if (this.returnTempAccount) {
    //   url.search = "returnTemp=true";
    // } else {
    //   url.search = "";
    // }
    const url = new URL(urlString);
    const response = await fetch(String(url), {
        credentials: 'include',
        method: 'get',
    });
    if (!response.ok) {
        throw new Error(t('error.endpoint', {
            default: `Login Endpoint Error {{status}} - {{statusText}}`,
            status: response.status,
            statusText: response.statusText,
        }));
    }
    const data = await response.json();
    return data;
}
async function popupLogin(t, urlString, timeout = 300000) {
    // Open the popup window
    const url = new URL(urlString);
    const popup = await window.open(url, 'WalletPluginCloudWalletPopup', 'height=800,width=600');
    if (!popup) {
        throw new Error(t('error.popup', {
            default: 'Unable to open the popup window. Check your browser settings and try again.',
        }));
    }
    // Return a promise that either times out or resolves when the popup resolves
    return new Promise((resolve, reject) => {
        const closeListener = registerCloseListener(t, popup, reject);
        // Event handler awaiting response from WCW
        const handleEvent = (event) => {
            if (!isValidEvent(event, url, popup)) {
                return;
            }
            try {
                resolve(event.data);
            }
            catch (e) {
                reject(e);
            }
            finally {
                window.removeEventListener('message', handleEvent);
                clearTimeout(autoCancel);
                clearInterval(closeListener);
            }
        };
        // Automatically cancel request after 5 minutes to cleanup windows/promises
        const autoCancel = setTimeout(() => {
            popup.close();
            window.removeEventListener('message', handleEvent);
            reject(new Error(t('error.timeout', {
                default: 'The request has timed out after {{timeout}} seconds. Please try again.',
                timeout: timeout / 1000,
            })));
        }, timeout);
        // Add event listener awaiting WCW Response
        window.addEventListener('message', handleEvent);
    });
}

function allowAutosign(request, data) {
    const ua = navigator.userAgent.toLowerCase();
    if (ua.search('chrome') === -1 && ua.search('safari') >= 0) {
        return false;
    }
    try {
        if (!data)
            return false;
        const whitelist = data.whitelist;
        const { actions } = request.resolvedTransaction;
        return actions.every((action) => {
            return whitelist.find((entry) => {
                if (action.account.equals(entry.contract)) {
                    if (action.account.equals('eosio.token') &&
                        action.name &&
                        action.name.equals('transfer')) {
                        return entry.recipients.includes(String(action.data.to));
                    }
                    return true;
                }
            });
        });
    }
    catch (e) {
        // console.log('error in canAutoSign', e)
    }
    return false;
}
async function autoSign(t, urlString, request) {
    const url = new URL(urlString);
    const controller = new AbortController();
    setTimeout(() => controller.abort(), 5000);
    const response = await fetch(url, {
        body: JSON.stringify({
            feeFallback: true,
            freeBandwidth: true,
            transaction: request.serializedTransaction,
        }),
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        method: 'POST',
        signal: controller.signal,
    });
    if (!response.ok) {
        throw new Error(t('error.endpoint', {
            default: `Login Endpoint Error {{status}} - {{statusText}}`,
            status: response.status,
            statusText: response.statusText,
        }));
    }
    const data = await response.json();
    if (data.processed && data.processed.except) {
        throw new Error(t('error.exception', {
            default: 'Signing exception occurred: {{exception}}',
            exception: JSON.stringify(data),
        }));
    }
    return data;
}
async function popupTransact(t, urlString, request, timeout = 300000) {
    const url = new URL(urlString);
    const popup = await window.open(url, 'WalletPluginCloudWalletPopup', 'height=800,width=600');
    if (!popup) {
        throw new Error(t('error.popup', {
            default: 'Unable to open the popup window. Check your browser settings and try again.',
        }));
    }
    return new Promise((resolve, reject) => {
        const closeListener = registerCloseListener(t, popup, reject);
        const handleEvent = (event) => {
            if (!isValidEvent(event, url, popup)) {
                return;
            }
            popup?.postMessage({
                feeFallback: true,
                freeBandwidth: true,
                startTime: getCurrentTime(),
                transaction: request.serializedTransaction,
                type: 'TRANSACTION',
            }, String(urlString));
            const handleSigning = (signingEvent) => {
                if (!isValidEvent(signingEvent, url, popup)) {
                    return;
                }
                try {
                    resolve(signingEvent.data);
                }
                catch (e) {
                    reject(e);
                }
                finally {
                    window.removeEventListener('message', handleEvent);
                    window.removeEventListener('message', handleSigning);
                    clearTimeout(autoCancel);
                    clearInterval(closeListener);
                }
            };
            window.addEventListener('message', handleSigning);
        };
        // Automatically cancel request after 5 minutes to cleanup windows/promises
        const autoCancel = setTimeout(() => {
            popup.close();
            window.removeEventListener('message', handleEvent);
            reject(new Error(t('error.timeout', {
                default: 'The request has timed out after {{timeout}} seconds. Please try again.',
                timeout: timeout / 1000,
            })));
        }, timeout);
        // Add event listener awaiting WCW Response
        window.addEventListener('message', handleEvent);
    });
}

var connecting$3 = "Connecting to Cloud Wallet";
var error$3 = {
	closed: "The Cloud Wallet was closed before the request was completed",
	endpoint: "Login Endpoint Error {{status}} - {{statusText}}",
	exception: "Signing exception occurred: {{exception}}",
	popup: "Unable to open the popup window. Check your browser settings and try again.",
	response: "The Cloud Wallet failed to respond.",
	timeout: "The request has timed out after {{timeout}} seconds. Please try again."
};
var login$3 = {
	popup: "Login with the Cloud Wallet popup window"
};
var transact$3 = {
	popup: "Sign with the Cloud Wallet popup window"
};
var en = {
	connecting: connecting$3,
	error: error$3,
	login: login$3,
	transact: transact$3
};

var connecting$2 = "클라우드 지갑에 연결";
var error$2 = {
	closed: "요청이 완료되기 전에 클라우드 지갑이 닫혔습니다.",
	endpoint: "로그인 엔드포인트 오류 {{status}} - {{statusText}}",
	exception: "서명 예외가 발생했습니다: {{exception}}",
	popup: "팝업 창을 열 수 없습니다. 브라우저 설정을 확인하고 다시 시도하십시오.",
	response: "클라우드 지갑이 응답하지 못했습니다.",
	timeout: "{{timeout}}초 후에 요청 시간이 초과되었습니다. 다시 시도하십시오."
};
var login$2 = {
	popup: "클라우드 지갑 팝업 창으로 로그인"
};
var transact$2 = {
	popup: "클라우드 지갑 팝업 창으로 서명"
};
var ko = {
	connecting: connecting$2,
	error: error$2,
	login: login$2,
	transact: transact$2
};

var connecting$1 = "正在连接到云钱包";
var error$1 = {
	closed: "云钱包在请求完成之前已关闭",
	endpoint: "登录端点错误 {{status}} - {{statusText}}",
	exception: "发生签名异常：{{exception}}",
	popup: "无法打开弹出窗口。请检查您的浏览器设置，然后重试。",
	response: "云钱包响应失败",
	timeout: "请求在 {{timeout}} 秒后超时。请重试。"
};
var login$1 = {
	popup: "使用云钱包弹出窗口登录"
};
var transact$1 = {
	popup: "使用云钱包弹出窗口签名"
};
var zh_hans = {
	connecting: connecting$1,
	error: error$1,
	login: login$1,
	transact: transact$1
};

var connecting = "正在連接到雲錢包";
var error = {
	closed: "雲錢包在請求完成之前已關閉",
	endpoint: "登錄端點錯誤 {{status}} - {{statusText}}",
	exception: "發生簽名異常：{{exception}}",
	popup: "無法打開彈出窗口。 請檢查您的瀏覽器設置，然後重試。",
	response: "雲錢包響應失敗",
	timeout: "請求在 {{timeout}} 秒後超時。請重試。"
};
var login = {
	popup: "使用雲錢包彈出窗口登錄"
};
var transact = {
	popup: "使用雲錢包彈出窗口簽名"
};
var zh_hant = {
	connecting: connecting,
	error: error,
	login: login,
	transact: transact
};

var defaultTranslations = {
    en,
    ko,
    'zh-Hans': zh_hans,
    'zh-Hant': zh_hant,
};

class WalletPluginCloudWallet extends AbstractWalletPlugin {
    /**
     * Constructor to allow overriding of plugin configuration.
     */
    constructor(options) {
        super();
        /**
         * The unique identifier for the wallet plugin.
         */
        this.id = 'cloudwallet';
        /**
         * The translations for this plugin
         */
        this.translations = defaultTranslations;
        /**
         * The logic configuration for the wallet plugin.
         */
        this.config = {
            // Should the user interface display a chain selector?
            requiresChainSelect: true,
            // Should the user interface display a permission selector?
            requiresPermissionSelect: false,
            // The blockchains this WalletPlugin supports
            supportedChains: [
                '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4', // WAX (Mainnet)
                // 'f16b1833c747c43682f4386fca9cbb327929334a762755ebec17f6f23c9b8a12', // NYI - WAX (Testnet)
            ],
        };
        /**
         * The metadata for the wallet plugin to be displayed in the user interface.
         */
        this.metadata = WalletPluginMetadata.from({
            name: 'Cloud Wallet',
            description: '',
            logo: 'PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTcuOTQ5NDMgMTkuMjU4MkM2LjE0OTM2IDE3LjQ1ODIgNi4xNDkzNiAxNC41NDE4IDcuOTQ5NDMgMTIuNzQxOEwxMi43NDE2IDcuOTVDMTQuNTQxNyA2LjE1MDA2IDE3LjQ1ODMgNi4xNTAwNiAxOS4yNTg0IDcuOTVMMjAuOTQ2NSA5LjYzNzk0TDI1LjYxNDEgNC45NzA2OEwyMy45MjYgMy4yODI3NEMxOS41NDg3IC0xLjA5NDI1IDEyLjQ1MTMgLTEuMDk0MjUgOC4wNzQgMy4yODI3NEwzLjI4Mjk3IDguMDc0NTdDLTEuMDk0MzIgMTIuNDUxNiAtMS4wOTQzMiAxOS41NDg0IDMuMjgyOTcgMjMuOTI1NEw0Ljk2MzAzIDI1LjYwNTRMOS42MzA2MyAyMC45MzgxTDcuOTUwNTcgMTkuMjU4Mkg3Ljk0OTQzWiIgZmlsbD0idXJsKCNwYWludDBfcmFkaWFsXzE4NDRfNTA4MikiLz4KPHBhdGggZD0iTTI4LjcxNjcgOC4wNzQ1N0wyNy4wMjg2IDYuMzg2NjNMMjIuMzYxIDExLjA1MzlMMjQuMDQ5MSAxMi43NDE4QzI1Ljg0OTIgMTQuNTQxOCAyNS44NDkyIDE3LjQ1ODIgMjQuMDQ5MSAxOS4yNTgyTDE4LjI3NzUgMTMuNDg2OUMxNi45ODgzIDEyLjE5NzggMTQuODk5MSAxMi4xOTc4IDEzLjYwOTkgMTMuNDg2OUMxMi4zMjA3IDE0Ljc3NiAxMi4zMjA3IDE2Ljg2NTEgMTMuNjA5OSAxOC4xNTQyTDE5LjM4MTUgMjMuOTI1NEwxOS4yNTY5IDI0LjA1QzE3LjQ1NjkgMjUuODQ5OSAxNC41NDAyIDI1Ljg0OTkgMTIuNzQwMSAyNC4wNUwxMS4wNDQxIDIyLjM1NDFMNi4zNzY0NiAyNy4wMjEzTDguMDcyNTMgMjguNzE3MkMxMi40NDk4IDMzLjA5NDIgMTkuNTQ3MiAzMy4wOTQyIDIzLjkyNDUgMjguNzE3MkwyNC4wNDkxIDI4LjU5MjdMMjguNzE2NyAyMy45MjU0QzMzLjA5NCAxOS41NDg0IDMzLjA5NCAxMi40NTE2IDI4LjcxNjcgOC4wNzQ1N1oiIGZpbGw9InVybCgjcGFpbnQxX3JhZGlhbF8xODQ0XzUwODIpIi8+CjxkZWZzPgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50MF9yYWRpYWxfMTg0NF81MDgyIiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDEyLjc5OTkgNC4yMjg5OSkgcm90YXRlKDkwKSBzY2FsZSgxNy44ODUxIDE3Ljg5MTEpIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzY2RkVGMiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMENGREMiLz4KPC9yYWRpYWxHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDFfcmFkaWFsXzE4NDRfNTA4MiIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgxOS4xODgxIDE5LjE5MzMpIHJvdGF0ZSg5MCkgc2NhbGUoMTIuODA2NyAxMi44MTE2KSI+CjxzdG9wIHN0b3AtY29sb3I9IiNDN0E1RUEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjN0Q0QkEzIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==',
            homepage: 'https://www.mycloudwallet.com',
            download: 'https://www.mycloudwallet.com',
        });
        /**
         * WAX Cloud Wallet Configuration
         */
        this.url = 'https://www.mycloudwallet.com';
        this.autoUrl = 'https://idm-api.mycloudwallet.com/v1/accounts/auto-accept';
        this.loginTimeout = 300000; // 5 minutes
        if (options?.supportedChains) {
            this.config.supportedChains = options.supportedChains;
        }
        if (options?.url) {
            this.url = options.url;
        }
        if (options?.autoUrl) {
            this.autoUrl = options.autoUrl;
        }
        if (options?.loginTimeout) {
            this.loginTimeout = options.loginTimeout;
        }
    }
    /**
     * Performs the wallet logic required to login and return the chain and permission level to use.
     *
     * @param options WalletPluginLoginOptions
     * @returns Promise<WalletPluginLoginResponse>
     */
    login(context) {
        const promise = this.waxLogin(context);
        return cancelable(promise, (canceled) => {
            throw canceled;
        });
    }
    async waxLogin(context) {
        if (!context.chain) {
            throw new Error('A chain must be selected to login with.');
        }
        // Retrieve translation helper from the UI, passing the app ID
        const t = context.ui.getTranslate(this.id);
        let response;
        try {
            // Attempt automatic login
            context.ui.status(t('connecting', { default: 'Connecting to Cloud Wallet' }));
            response = await autoLogin(t, `${this.autoUrl}/login`);
        }
        catch (e) {
            // Fallback to popup login
            context.ui.status(t('login.popup', { default: 'Login with the Cloud Wallet popup window' }));
            response = await popupLogin(t, `${this.url}/cloud-wallet/login/`);
        }
        // If failed due to no response or no verified response, throw error
        if (!response) {
            throw new Error(t('login.error.response', { default: 'Cloud Wallet failed to respond' }));
        }
        if (!response.verified) {
            throw new Error(t('error.closed', {
                default: 'Cloud Wallet closed before the login was completed',
            }));
        }
        // Save our whitelisted contracts
        this.data.whitelist = response.whitelistedContracts;
        return new Promise((resolve) => {
            if (!context.chain) {
                throw new Error('A chain must be selected to login with.');
            }
            // Return to session's transact call
            resolve({
                chain: context.chain.id,
                permissionLevel: PermissionLevel.from({
                    actor: response.userAccount,
                    permission: 'active',
                }),
            });
        });
    }
    /**
     * Performs the wallet logic required to sign a transaction and return the signature.
     *
     * @param chain ChainDefinition
     * @param resolved ResolvedSigningRequest
     * @returns Promise<Signature>
     */
    sign(resolved, context) {
        const promise = this.waxSign(resolved, context);
        return cancelable(promise, (canceled) => {
            throw canceled;
        });
    }
    async waxSign(resolved, context) {
        if (!context.ui) {
            throw new Error('A UserInterface must be defined to sign transactions.');
        }
        // Retrieve translation helper from the UI, passing the app ID
        const t = context.ui.getTranslate(this.id);
        // Set expiration time frames for the request
        const expiration = resolved.transaction.expiration.toDate();
        const now = new Date();
        const timeout = Math.floor(expiration.getTime() - now.getTime());
        // Perform WAX Cloud Wallet signing
        const callbackPromise = this.getWalletResponse(resolved, context, t, timeout);
        // Tell Wharf we need to prompt the user with a countdown
        const promptPromise = context.ui.prompt({
            title: 'Sign',
            body: `Please complete the transaction using the Cloud Wallet popup window.`,
            elements: [
                {
                    type: 'countdown',
                    data: expiration.toISOString(),
                },
            ],
        });
        // Create a timer to test the external cancelation of the prompt, if defined
        const timer = setTimeout(() => {
            if (!context.ui) {
                throw new Error('No UI defined');
            }
            promptPromise.cancel('The request expired, please try again.');
        }, timeout);
        // Clear the timeout if the UI throws (which generally means it closed)
        promptPromise.catch(() => clearTimeout(timer));
        // Wait for either the callback or the prompt to resolve
        const callbackResponse = await Promise.race([callbackPromise, promptPromise]).finally(() => {
            // Clear the automatic timeout once the race resolves
            clearTimeout(timer);
        });
        if (isCallback(callbackResponse)) {
            // Determine if there are any fees to accept
            const hasFees = callbackResponse.waxFee || callbackResponse.ramFee;
            if (hasFees) {
                throw new Error('The transaction requires a fee, and the fee interface is not yet implemented.');
            }
            // The response to return to the Session Kit
            const result = {
                signatures: callbackResponse.signatures,
            };
            // If a transaction was returned by the WCW
            if (callbackResponse.serializedTransaction) {
                // Convert the serialized transaction from the WCW to a Transaction object
                const responseTransaction = Serializer.decode({
                    data: callbackResponse.serializedTransaction,
                    type: Transaction,
                });
                // Determine if the transaction changed from the requested transaction
                if (!responseTransaction.equals(resolved.transaction)) {
                    // Evalutate whether modifications are valid, if not throw error
                    validateModifications(resolved.transaction, responseTransaction);
                    // If changed, add the modified request returned by WCW to the response
                    result.request = await SigningRequest.create({
                        transaction: responseTransaction,
                    }, context.esrOptions);
                }
            }
            return new Promise((resolve) => resolve(result));
        }
        throw new Error('The Cloud Wallet failed to respond');
    }
    async getWalletResponse(resolved, context, t, timeout = 300000) {
        let response;
        if (!context.ui) {
            throw new Error('The Cloud Wallet requires a UI to sign transactions.');
        }
        // Check if automatic signing is allowed
        if (allowAutosign(resolved, this.data)) {
            try {
                // Try automatic signing
                context.ui.status(t('connecting', { default: 'Connecting to Cloud Wallet' }));
                response = await autoSign(t, `${this.autoUrl}/signing`, resolved);
            }
            catch (e) {
                // Fallback to poup signing
                context.ui.status(t('transact.popup', { default: 'Sign with the Cloud Wallet popup window' }));
                response = await popupTransact(t, `${this.url}/cloud-wallet/signing/`, resolved, timeout);
            }
        }
        else {
            // If automatic is not allowed use the popup
            context.ui.status(t('transact.popup', { default: 'Sign with the Cloud Wallet popup window' }));
            response = await popupTransact(t, `${this.url}/cloud-wallet/signing/`, resolved, timeout);
        }
        // Catch unknown errors where no response is returned
        if (!response) {
            throw new Error(t('login.error.response', { default: 'Cloud Wallet failed to respond' }));
        }
        // Ensure the response is verified, if not the user most likely cancelled the request
        if (!response.verified) {
            throw new Error(t('error.closed', {
                default: 'The Cloud Wallet was closed before the request was completed',
            }));
        }
        // Save our whitelisted contracts
        this.data.whitelist = response.whitelistedContracts;
        // Return the response from the API
        return response;
    }
}
function isCallback(object) {
    return 'serializedTransaction' in object;
}

export { WalletPluginCloudWallet };
//# sourceMappingURL=wallet-plugin-cloudwallet.m.js.map
