import { Struct, Name, PublicKey, Weight, UInt32, PermissionLevel, AbstractUserInterface, cancelable, Canceled } from '@wharfkit/session';

function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    if (value === null) {
        node.style.removeProperty(key);
    }
    else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
function construct_svelte_component(component, props) {
    return new component(props);
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
const managed_styles = new Map();
let active$1 = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_style_information(doc, node) {
    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
    managed_styles.set(doc, info);
    return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
    if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active$1 += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active$1 -= deleted;
        if (!active$1)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active$1)
            return;
        managed_styles.forEach(info => {
            const { ownerNode } = info.stylesheet;
            // there is no ownerNode if it runs on jsdom.
            if (ownerNode)
                detach(ownerNode);
        });
        managed_styles.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs#run-time-svelte-ondestroy
 */
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
 */
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-setcontext
 */
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
    return context;
}
/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-getcontext
 */
function getContext(key) {
    return get_current_component().$$.context.get(key);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    // Do not reenter flush while dirty components are updated, as this can
    // result in an infinite loop. Instead, let the inner flush handle it.
    // Reentrancy is ok afterwards for bindings etc.
    if (flushidx !== 0) {
        return;
    }
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        try {
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
        }
        catch (e) {
            // reset dirty state to not end up in a deadlocked state and then rethrow
            dirty_components.length = 0;
            flushidx = 0;
            throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    const options = { direction: 'in' };
    let config = fn(node, params, options);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config(options);
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    const options = { direction: 'both' };
    let config = fn(node, params, options);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config(options);
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
            // if the component was destroyed immediately
            // it will update the `$$.on_destroy` reference to `null`.
            // the destructured on_destroy may still reference to the old array
            if (component.$$.on_destroy) {
                component.$$.on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        if (!is_function(callback)) {
            return noop;
        }
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
        };
    });
}

var q$1=Object.defineProperty,B$1=Object.defineProperties;var G$1=Object.getOwnPropertyDescriptors;var S$1=Object.getOwnPropertySymbols;var N$1=Object.prototype.hasOwnProperty,A$1=Object.prototype.propertyIsEnumerable;var j=(s,e,t)=>e in s?q$1(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,n$1=(s,e)=>{for(var t in e||(e={}))N$1.call(e,t)&&j(s,t,e[t]);if(S$1)for(var t of S$1(e))A$1.call(e,t)&&j(s,t,e[t]);return s},d$2=(s,e)=>B$1(s,G$1(e));var m$1=(s,e)=>{var t={};for(var r in s)N$1.call(s,r)&&e.indexOf(r)<0&&(t[r]=s[r]);if(s!=null&&S$1)for(var r of S$1(s))e.indexOf(r)<0&&A$1.call(s,r)&&(t[r]=s[r]);return t};var R$1=["error","warn","debug"],F=({logger:s=console,level:e=R$1[1],prefix:t="[i18n]: "})=>R$1.reduce((r,a,o)=>d$2(n$1({},r),{[a]:i=>R$1.indexOf(e)>=o&&s[a](`${t}${i}`)}),{}),l$1=F({}),E$1=s=>{l$1=s;};var O$1=g=>{var u=g,{parser:s,key:e,params:t,translations:r,locale:a,fallbackLocale:o}=u,i=m$1(u,["parser","key","params","translations","locale","fallbackLocale"]);if(!(e&&a))return l$1.warn("No translation key or locale provided. Skipping translation..."),"";let p=(r[a]||{})[e];return o&&p===void 0&&(p=(r[o]||{})[e]),i.hasOwnProperty("fallbackValue")&&p===void 0?i.fallbackValue:s.parse(p,t,a,e)},f$1=(...s)=>s.length?s.filter(e=>!!e).map(e=>{let t=`${e}`.toLowerCase();try{let[r]=Intl.Collator.supportedLocalesOf(e);if(!r)throw new Error(`'${e}' is non-standard.`);t=r;}catch{l$1.warn(`Non-standard locale provided: '${e}'. Check your 'translations' and 'loaders' in i18n config...`);}return t}):[],w$1=(s,e)=>Object.keys(s||{}).reduce((t,r)=>{let a=s[r],o=e?`${e}.${r}`:`${r}`;return a&&typeof a=="object"?n$1(n$1({},t),w$1(a,o)):d$2(n$1({},t),{[o]:a})},{}),W$1=async s=>{try{return (await Promise.all(s.map(a=>{var o=a,{loader:t}=o,r=m$1(o,["loader"]);return new Promise(async i=>{let g;try{g=await t();}catch(u){l$1.error(`Failed to load translation. Verify your '${r.locale}' > '${r.key}' Loader.`),l$1.error(u);}i(d$2(n$1({loader:t},r),{data:g}));})}))).reduce((t,{key:r,data:a,locale:o})=>{if(!a)return t;let[i]=f$1(o);return d$2(n$1({},t),{[i]:w$1(d$2(n$1({},t[i]||{}),{[r]:a}))})},{})}catch(e){l$1.error(e);}return {}},D$1=s=>e=>{try{if(typeof e=="string")return e===s;if(typeof e=="object")return e.test(s)}catch{l$1.error("Invalid route config!");}return !1},I=(s,e)=>{let t=!0;try{t=Object.keys(s).filter(r=>s[r]!==void 0).every(r=>s[r]===e[r]);}catch{}return t};var H$1=1e3*60*60*24,z$1=class{constructor(e){this.cachedAt=0;this.loadedKeys={};this.currentRoute=writable();this.config=writable();this.isLoading=writable(!1);this.promises=new Set;this.loading={subscribe:this.isLoading.subscribe,toPromise:(e,t)=>{let r=Array.from(this.promises).filter(a=>I({locale:f$1(e)[0],route:t},a)).map(({promise:a})=>a);return Promise.all(r)},get:()=>get_store_value(this.isLoading)};this.privateTranslations=writable({});this.translations={subscribe:this.privateTranslations.subscribe,get:()=>get_store_value(this.translations)};this.locales=d$2(n$1({},derived([this.config,this.privateTranslations],([e,t])=>{if(!e)return [];let{loaders:r=[]}=e,a=r.map(({locale:i})=>i),o=Object.keys(t).map(i=>i);return Array.from(new Set([...f$1(...a),...f$1(...o)]))},[])),{get:()=>get_store_value(this.locales)});this.internalLocale=writable();this.loaderTrigger=derived([this.internalLocale,this.currentRoute],([e,t],r)=>{var a,o;e!==void 0&&t!==void 0&&!(e===((a=get_store_value(this.loaderTrigger))==null?void 0:a[0])&&t===((o=get_store_value(this.loaderTrigger))==null?void 0:o[1]))&&(l$1.debug("Triggering translation load..."),r([e,t]));},[]);this.localeHelper=writable();this.locale={subscribe:this.localeHelper.subscribe,forceSet:this.localeHelper.set,set:this.internalLocale.set,update:this.internalLocale.update,get:()=>get_store_value(this.locale)};this.initialized=derived([this.locale,this.currentRoute,this.privateTranslations],([e,t,r],a)=>{get_store_value(this.initialized)||a(e!==void 0&&t!==void 0&&!!Object.keys(r).length);});this.translation=derived([this.privateTranslations,this.locale,this.isLoading],([e,t,r],a)=>{let o=e[t];o&&Object.keys(o).length&&!r&&a(o);},{});this.t=d$2(n$1({},derived([this.config,this.translation],a=>{var[o]=a,i=o,{parser:e,fallbackLocale:t}=i,r=m$1(i,["parser","fallbackLocale"]);return (g,...u)=>O$1(n$1({parser:e,key:g,params:u,translations:this.translations.get(),locale:this.locale.get(),fallbackLocale:t},r.hasOwnProperty("fallbackValue")?{fallbackValue:r.fallbackValue}:{}))})),{get:(e,...t)=>get_store_value(this.t)(e,...t)});this.l=d$2(n$1({},derived([this.config,this.translations],o=>{var[i,...g]=o,u=i,{parser:e,fallbackLocale:t}=u,r=m$1(u,["parser","fallbackLocale"]),[a]=g;return (p,v,...k)=>O$1(n$1({parser:e,key:v,params:k,translations:a,locale:p,fallbackLocale:t},r.hasOwnProperty("fallbackValue")?{fallbackValue:r.fallbackValue}:{}))})),{get:(e,t,...r)=>get_store_value(this.l)(e,t,...r)});this.getLocale=e=>{let{fallbackLocale:t=""}=get_store_value(this.config)||{},r=e||t;if(!r)return "";let a=this.locales.get();return a.find(i=>f$1(r).includes(i))||a.find(i=>f$1(t).includes(i))||""};this.setLocale=e=>{if(!!e&&e!==get_store_value(this.internalLocale))return l$1.debug(`Setting '${e}' locale.`),this.internalLocale.set(e),this.loading.toPromise(e,get_store_value(this.currentRoute))};this.setRoute=e=>{if(e!==get_store_value(this.currentRoute)){l$1.debug(`Setting '${e}' route.`),this.currentRoute.set(e);let t=get_store_value(this.internalLocale);return this.loading.toPromise(t,e)}};this.loadConfig=async e=>{await this.configLoader(e);};this.getTranslationProps=async(e=this.locale.get(),t=get_store_value(this.currentRoute))=>{let r=get_store_value(this.config);if(!r||!e)return [];let a=this.translations.get(),{loaders:o,fallbackLocale:i="",cache:g=H$1}=r||{},u=Number.isNaN(+g)?H$1:+g;this.cachedAt?Date.now()>u+this.cachedAt&&(l$1.debug("Refreshing cache."),this.loadedKeys={},this.cachedAt=0):(l$1.debug("Setting cache timestamp."),this.cachedAt=Date.now());let[p,v]=f$1(e,i),k=a[p],M=a[v],C=(o||[]).map(K=>{var L=K,{locale:h}=L,b=m$1(L,["locale"]);return d$2(n$1({},b),{locale:f$1(h)[0]})}).filter(({routes:h})=>!h||(h||[]).some(D$1(t))).filter(({key:h,locale:b})=>b===p&&(!k||!(this.loadedKeys[p]||[]).includes(h))||i&&b===v&&(!M||!(this.loadedKeys[v]||[]).includes(h)));if(C.length){this.isLoading.set(!0),l$1.debug("Fetching translations...");let h=await W$1(C);this.isLoading.set(!1);let b=Object.keys(h).reduce((L,y)=>d$2(n$1({},L),{[y]:Object.keys(h[y])}),{}),K=C.filter(({key:L,locale:y})=>(b[y]||[]).some(x=>`${x}`.startsWith(L))).reduce((L,{key:y,locale:x})=>d$2(n$1({},L),{[x]:[...L[x]||[],y]}),{});return [h,K]}return []};this.addTranslations=(e,t)=>{if(!e)return;l$1.debug("Adding translations...");let r=Object.keys(e||{});this.privateTranslations.update(a=>r.reduce((o,i)=>d$2(n$1({},o),{[i]:n$1(n$1({},o[i]||{}),w$1(e[i]))}),a)),r.forEach(a=>{let o=Object.keys(e[a]).map(i=>`${i}`.split(".")[0]);t&&(o=t[a]),this.loadedKeys[a]=Array.from(new Set([...this.loadedKeys[a]||[],...o||[]]));});};this.loader=async([e,t])=>{let r=this.getLocale(e);l$1.debug(`Adding loader promise for '${r}' locale and '${t}' route.`);let a=(async()=>{let o=await this.getTranslationProps(r,t);o.length&&this.addTranslations(...o);})();this.promises.add({locale:r,route:t,promise:a}),a.then(()=>{r&&this.locale.get()!==r&&this.locale.forceSet(r);});};this.loadTranslations=(e,t=get_store_value(this.currentRoute)||"")=>{let r=this.getLocale(e);if(!!r)return this.setRoute(t),this.setLocale(r),this.loading.toPromise(r,t)};this.loaderTrigger.subscribe(this.loader),this.isLoading.subscribe(async t=>{t&&this.promises.size&&(await this.loading.toPromise(),this.promises.clear(),l$1.debug("Loader promises have been purged."));}),e&&this.loadConfig(e);}async configLoader(e){if(!e)return l$1.error("No config provided!");let g=e,{initLocale:t,fallbackLocale:r,translations:a,log:o}=g,i=m$1(g,["initLocale","fallbackLocale","translations","log"]);o&&E$1(F(o)),[t]=f$1(t),[r]=f$1(r),l$1.debug("Setting config."),this.config.set(n$1({initLocale:t,fallbackLocale:r,translations:a},i)),a&&this.addTranslations(a),await this.loadTranslations(t);}};

var R=Object.defineProperty,E=Object.defineProperties;var v$1=Object.getOwnPropertyDescriptors;var k=Object.getOwnPropertySymbols;var C=Object.prototype.hasOwnProperty,O=Object.prototype.propertyIsEnumerable;var w=(t,e,r)=>e in t?R(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,u$1=(t,e)=>{for(var r in e||(e={}))C.call(e,r)&&w(t,r,e[r]);if(k)for(var r of k(e))O.call(e,r)&&w(t,r,e[r]);return t},$=(t,e)=>E(t,v$1(e));var d$1=(t,e)=>{var r={};for(var i in t)C.call(t,i)&&e.indexOf(i)<0&&(r[i]=t[i]);if(t!=null&&k)for(var i of k(t))e.indexOf(i)<0&&O.call(t,i)&&(r[i]=t[i]);return r};var z=(t,e)=>{for(var r in e)R(t,r,{get:e[r],enumerable:!0});};var h={};z(h,{ago:()=>X,date:()=>Q,eq:()=>p$1,gt:()=>q,gte:()=>H,lt:()=>U,lte:()=>G,ne:()=>B,number:()=>J});var T=(t,e)=>{let{modifierDefaults:r}=e||{},{[t]:i}=r||{};return i||{}};var p$1=({value:t,options:e=[],defaultValue:r=""})=>(e.find(({key:i})=>`${i}`.toLowerCase()===`${t}`.toLowerCase())||{}).value||r,B=({value:t,options:e=[],defaultValue:r=""})=>(e.find(({key:i})=>`${i}`.toLowerCase()!==`${t}`.toLowerCase())||{}).value||r,U=({value:t,options:e=[],defaultValue:r=""})=>(e.sort((o,n)=>+o.key-+n.key).find(({key:o})=>+t<+o)||{}).value||r,q=({value:t,options:e=[],defaultValue:r=""})=>(e.sort((o,n)=>+n.key-+o.key).find(({key:o})=>+t>+o)||{}).value||r,G=({value:t,options:e=[],defaultValue:r=""})=>p$1({value:t,options:e,defaultValue:U({value:t,options:e,defaultValue:r})}),H=({value:t,options:e=[],defaultValue:r=""})=>p$1({value:t,options:e,defaultValue:q({value:t,options:e,defaultValue:r})}),J=({value:t,props:e,defaultValue:r="",locale:i="",parserOptions:o})=>{if(!i)return "";let s=T("number",o),{maximumFractionDigits:n}=s,m=d$1(s,["maximumFractionDigits"]),c=(e==null?void 0:e.number)||{},{maximumFractionDigits:f=n||2}=c,a=d$1(c,["maximumFractionDigits"]);return new Intl.NumberFormat(i,u$1($(u$1({},m),{maximumFractionDigits:f}),a)).format(+t||+r)},Q=({value:t,props:e,defaultValue:r="",locale:i="",parserOptions:o})=>{if(!i)return "";let n=d$1(T("date",o),[]),m=d$1((e==null?void 0:e.date)||{},[]);return new Intl.DateTimeFormat(i,u$1(u$1({},n),m)).format(+t||+r)},P$1=[{key:"second",multiplier:1e3},{key:"minute",multiplier:60},{key:"hour",multiplier:60},{key:"day",multiplier:24},{key:"week",multiplier:7},{key:"month",multiplier:13/3},{key:"year",multiplier:12}],N=(t="",e="")=>new RegExp(`^${t}s?$`).test(e),S=t=>P$1.indexOf(P$1.find(({key:e})=>N(e,t))),W=(t,e)=>P$1.reduce(([r,i],{key:o,multiplier:n},m)=>{if(N(i,e))return [r,i];if(!i||m===S(i)+1){let f=Math.round(r/n);if(!i||Math.abs(f)>=1||e!=="auto")return [f,o]}return [r,i]},[t,""]),X=({value:t,defaultValue:e="",locale:r="",props:i,parserOptions:o})=>{if(!r)return "";let g=T("ago",o),{format:n,numeric:m}=g,f=d$1(g,["format","numeric"]),l=(i==null?void 0:i.ago)||{},{format:a=n||"auto",numeric:s=m||"auto"}=l,c=d$1(l,["format","numeric"]),x=+t||+e,M=W(x,a);return new Intl.RelativeTimeFormat(r,u$1($(u$1({},f),{numeric:s}),c)).format(...M)};var Y=t=>typeof t=="string"&&/{{(?:(?!{{|}}).)+}}/.test(t),D=t=>typeof t=="string"?t.replace(/\\(?=:|;|{|})/g,""):t,Z=({value:t,props:e,payload:r,parserOptions:i,locale:o})=>`${t}`.replace(/{{\s*(?:(?!{{|}}).)+\s*}}/g,n=>{let m=D(`${n.match(/(?!{|\s).+?(?!\\[:;]).(?=\s*(?:[:;]|}}$))/)}`),f=r==null?void 0:r[m],[,a=""]=n.match(/.+?(?!\\;).;\s*default\s*:\s*([^\s:;].+?(?:\\[:;]|[^;\s}])*)(?=\s*(?:;|}}$))/i)||[];a=a||(r==null?void 0:r.default)||"";let[,s=""]=n.match(/{{\s*(?:[^;]|(?:\\;))+\s*(?:(?!\\:).[:])\s*(?!\s)((?:\\;|[^;])+?)(?=\s*(?:[;]|}}$))/i)||[];if(f===void 0&&s!=="ne")return a;let c=!!s,{customModifiers:x}=i||{},M=u$1(u$1({},h),x||{});s=Object.keys(M).includes(s)?s:"eq";let g=M[s],l=(n.match(/[^\s:;{](?:[^;]|\\[;])+[^\s:;}]/gi)||[]).reduce((F,b,j)=>{if(j>0){let y=D(`${b.match(/(?:(?:\\:)|[^:])+/)}`.trim()),I=`${b.match(/(?:(?:\\:)|[^:])+$/)}`.trim();if(y&&y!=="default"&&I)return [...F,{key:y,value:I}]}return F},[]);return !c&&!l.length?f:g({value:f,options:l,props:e,defaultValue:a,locale:o,parserOptions:i})}),A=({value:t,props:e,payload:r,parserOptions:i,locale:o})=>{if(Y(t)){let n=Z({value:t,payload:r,props:e,parserOptions:i,locale:o});return A({value:n,payload:r,props:e,parserOptions:i,locale:o})}else return D(t)},_=t=>({parse:(e,[r,i],o,n)=>((r==null?void 0:r.default)&&e===void 0&&(e=`${r.default}`),e===void 0&&(e=`${n}`),A({value:e,payload:r,props:i,parserOptions:t,locale:o}))}),rt=_;

var n=Object.defineProperty,M=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var f=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable;var i=(r,o,e)=>o in r?n(r,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[o]=e,p=(r,o)=>{for(var e in o||(o={}))f.call(o,e)&&i(r,e,o[e]);if(s)for(var e of s(o))P.call(o,e)&&i(r,e,o[e]);return r},d=(r,o)=>M(r,u(o));var l=(r,o)=>{var e={};for(var a in r)f.call(r,a)&&o.indexOf(a)<0&&(e[a]=r[a]);if(r!=null&&s)for(var a of s(r))o.indexOf(a)<0&&P.call(r,a)&&(e[a]=r[a]);return e};var m=e=>{var a=e,{parserOptions:r={}}=a,o=l(a,["parserOptions"]);return d(p({},o),{parser:rt(r)})},t=class extends z$1{constructor(e){super(e&&m(e));this.loadConfig=e=>super.configLoader(m(e));}},v=t;

var en$1 = "English";
var kr = "한국어";
var zh = "中文";
var lang = {
	en: en$1,
	kr: kr,
	zh: zh,
	"zh-Hans": "中文简体",
	"zh-Hant": "中文繁体"
};

var accept$3 = "Accept";
var cancel$3 = "Cancel";
var close$3 = "Close";
var decline$3 = "Decline";
var error$3 = {
	title: "Error",
	subtitle: "An Error happened."
};
var loading$3 = "Loading...";
var login$3 = {
	complete: "Complete the login using your selected wallet.",
	enter: {
		account: "Enter account name",
		lookup: "Lookup Account",
		not_found: "Unable to find account"
	},
	select: {
		account: "Select an Account",
		blockchain: "Select a Blockchain",
		wallet: "Select a Wallet",
		no_match: "No accounts found matching {{publicKey}}"
	},
	title: "Login",
	subtitle: "Please login to continue",
	"title-app": "{{appName}}"
};
var transact$3 = {
	title: "Transact",
	subtitle: " ",
	processing: "Processing transaction...",
	signing: "Signing transaction",
	signed: "Transaction signed",
	broadcasting: "Broadcasting transaction",
	broadcasted: "Transaction broadcasted!"
};
var en = {
	accept: accept$3,
	cancel: cancel$3,
	close: close$3,
	decline: decline$3,
	error: error$3,
	loading: loading$3,
	login: login$3,
	transact: transact$3
};

var accept$2 = "받아들이다";
var cancel$2 = "취소";
var close$2 = "닫다";
var decline$2 = "거절하다";
var error$2 = {
	title: "오류",
	subtitle: "오류가 발생했습니다."
};
var loading$2 = "로드...";
var login$2 = {
	complete: "선택한 지갑을 사용하여 로그인을 완료합니다.",
	enter: {
		account: "Enter account name",
		lookup: "Lookup Account",
		not_found: "Unable to find account"
	},
	select: {
		account: "계정 선택",
		blockchain: "블록체인 선택",
		wallet: "지갑 선택",
		no_match: "{{publicKey}}와 일치하는 계정을 찾을 수 없습니다."
	},
	title: "로그인",
	subtitle: "계속하려면 로그인하십시오",
	"title-app": "{{appName}}에 로그인"
};
var transact$2 = {
	title: "거래하다",
	subtitle: " ",
	processing: "Processing transaction...",
	signing: "서명 트랜잭션",
	signed: "트랜잭션 서명",
	broadcasting: "방송 거래",
	broadcasted: "거래 방송"
};
var ko = {
	accept: accept$2,
	cancel: cancel$2,
	close: close$2,
	decline: decline$2,
	error: error$2,
	loading: loading$2,
	login: login$2,
	transact: transact$2
};

var accept$1 = "接受";
var cancel$1 = "取消";
var close$1 = "关闭";
var decline$1 = "下降";
var error$1 = {
	title: "错误",
	subtitle: "发生错误。"
};
var loading$1 = "加载中。。。";
var login$1 = {
	complete: "使用您选择的钱包完成登陆。",
	enter: {
		account: "Enter account name",
		lookup: "Lookup Account",
		not_found: "Unable to find account"
	},
	select: {
		account: "选择一个帐户",
		blockchain: "选择一个区块链",
		wallet: "选择一个钱包",
		no_match: "未找到与 {{publicKey}} 匹配的帐户。"
	},
	title: "登陆",
	subtitle: "请登陆以继续",
	"title-app": "登陆到 {{appName}}"
};
var transact$1 = {
	title: "办理",
	subtitle: " ",
	processing: "Processing transaction...",
	signing: "签署交易",
	signed: "交易已签署",
	broadcasting: "广播交易",
	broadcasted: "交易广播"
};
var zh_hans = {
	accept: accept$1,
	cancel: cancel$1,
	close: close$1,
	decline: decline$1,
	error: error$1,
	loading: loading$1,
	login: login$1,
	transact: transact$1
};

var accept = "接受";
var cancel = "取消";
var close = "關閉";
var decline = "下降";
var error = {
	title: "錯誤",
	subtitle: "發生錯誤。"
};
var loading = "裝載。。。";
var login = {
	complete: "使用您選擇的錢包完成登錄。",
	enter: {
		account: "Enter account name",
		lookup: "Lookup Account",
		not_found: "Unable to find account"
	},
	select: {
		account: "選擇一個帳戶",
		blockchain: "選擇一個區塊鏈",
		wallet: "選擇一個錢包",
		no_match: "未找到與 {{publicKey}} 匹配的帳戶。"
	},
	title: "登錄",
	subtitle: "請登錄以繼續",
	"title-app": "登錄到 {{appName}}"
};
var transact = {
	title: "辦理",
	subtitle: "",
	processing: "Processing transaction...",
	signing: "簽署交易",
	signed: "交易已簽署",
	broadcasting: "廣播交易",
	broadcasted: "交易廣播"
};
var zh_hant = {
	accept: accept,
	cancel: cancel,
	close: close,
	decline: decline,
	error: error,
	loading: loading,
	login: login,
	transact: transact
};

const translations = {
    en: { ...lang, ...en },
    ko: { ...lang, ...ko },
    zh: { ...lang, ...zh_hans },
    'zh-Hans': { ...lang, ...zh_hans },
    'zh-Hant': { ...lang, ...zh_hant },
};
const config = {
    initLocale: 'en',
    translations,
};
const makeLocalization = (options = {}) => {
    const params = {
        ...config,
        ...options,
    };
    return new v(params);
};
new v(config);

/* src/ui/components/ErrorMessage.svelte generated by Svelte v3.55.1 */

function add_css$l(target) {
	append_styles(target, "svelte-1odcxqq", "div.svelte-1odcxqq{display:flex;flex-direction:column;align-items:center;gap:var(--space-s);text-align:center;color:var(--body-text-color);margin-block:var(--space-s)}svg.svelte-1odcxqq{--size:var(--space-3xl);width:var(--size);height:var(--size);stroke:var(--color-error-2)}h2.svelte-1odcxqq{color:var(--body-text-color);font-size:var(--fs-3);font-weight:600;margin:0}p.svelte-1odcxqq{color:var(--body-text-color);font-size:var(--fs-1);font-weight:400;margin:0;max-width:var(--measure)}");
}

function create_fragment$D(ctx) {
	let div;
	let svg;
	let polygon;
	let line0;
	let line1;
	let t0;
	let h2;
	let t1;
	let t2;
	let p;
	let t3;

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t0 = space();
			h2 = element("h2");
			t1 = text(/*title*/ ctx[0]);
			t2 = space();
			p = element("p");
			t3 = text(/*details*/ ctx[1]);
			attr(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
			attr(line0, "x1", "15");
			attr(line0, "y1", "9");
			attr(line0, "x2", "9");
			attr(line0, "y2", "15");
			attr(line1, "x1", "9");
			attr(line1, "y1", "9");
			attr(line1, "x2", "15");
			attr(line1, "y2", "15");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", "svelte-1odcxqq");
			attr(h2, "class", "svelte-1odcxqq");
			attr(p, "class", "svelte-1odcxqq");
			attr(div, "class", "svelte-1odcxqq");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);
			append(svg, polygon);
			append(svg, line0);
			append(svg, line1);
			append(div, t0);
			append(div, h2);
			append(h2, t1);
			append(div, t2);
			append(div, p);
			append(p, t3);
		},
		p(ctx, [dirty]) {
			if (dirty & /*title*/ 1) set_data(t1, /*title*/ ctx[0]);
			if (dirty & /*details*/ 2) set_data(t3, /*details*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { details } = $$props;

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('details' in $$props) $$invalidate(1, details = $$props.details);
	};

	return [title, details];
}

class ErrorMessage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$u, create_fragment$D, safe_not_equal, { title: 0, details: 1 }, add_css$l);
	}
}

function isUrlImage(str) {
    return str.startsWith('http://') || str.startsWith('https://');
}
function isBase64Image(str) {
    return str.startsWith('data:image/');
}
// Returns a themed logo based on the wallet metadata and the current color scheme preference
function getThemedLogo(metadata) {
    const { name, logo } = metadata;
    const theme = get_store_value(colorScheme);
    const oppositeColorScheme = theme === 'light' ? 'dark' : 'light';
    if (!logo) {
        if ('getLogo' in metadata) {
            return metadata.getLogo()?.[theme] ?? metadata.getLogo()?.[oppositeColorScheme];
        }
        console.warn(`${name} does not have a logo.`);
        return;
    }
    if (!isUrlImage(logo.toString()) && !isBase64Image(logo.toString())) {
        console.warn(`${name} ${theme} logo is not a supported image format.`);
        return;
    }
    return logo[theme] ?? logo[oppositeColorScheme];
}
function getStoredColorScheme() {
    return localStorage.getItem('colorScheme');
}

// Reset data in all stores
function resetState() {
    active.set(false);
    props.set({ ...defaultUserInterfaceProps });
    router.set({ ...defaultUserInterfaceRouter });
    prompt.reset();
    cancelablePromises.set([]);
    transactContext.set(undefined);
    loginContext.set(undefined);
    loginPromise.set(undefined);
    loginResponse.set({ ...defaultLoginResponse });
    errorDetails.set(undefined);
    backAction.set(undefined);
}
/** Whether or not the interface is active in the browser */
const active = writable(false);
const defaultUserInterfaceProps = {
    language: 'en',
    subtitle: 'Status Message',
    title: 'Wharf',
};
const props = writable(defaultUserInterfaceProps);
const defaultUserInterfaceRouter = {
    path: '',
    history: [],
};
const initRouter = () => {
    const { set, subscribe, update } = writable(defaultUserInterfaceRouter);
    return {
        // Method to go one back in history
        back: () => update((current) => ({
            ...current,
            path: current.history[current.history.length - 1],
            history: current.history.slice(0, -1),
        })),
        // Push a new path on to history
        push: (path) => update((current) => ({
            ...current,
            path,
            history: [...current.history, current.path],
        })),
        set,
        subscribe,
        update,
    };
};
const router = initRouter();
const cancelablePromises = writable([]);
const transactContext = writable(undefined);
const initPrompt = () => {
    const { set, subscribe, update } = writable(undefined);
    return {
        reset: () => set(undefined),
        set,
        subscribe,
        update,
    };
};
const prompt = initPrompt();
const defaultLoginResponse = {
    chainId: undefined,
    permissionLevel: undefined,
    walletPluginIndex: undefined,
};
const loginContext = writable(undefined);
const loginPromise = writable(undefined);
const loginResponse = writable({ ...defaultLoginResponse });
const errorDetails = writable(undefined);
const backAction = writable(undefined);
// define a writable store to hold the color scheme preference and set the initial color scheme preference based on localStorage
const colorScheme = writable(getStoredColorScheme());
// listen for changes to the color scheme preference and update localStorage
colorScheme.subscribe((value) => {
    if (value)
        localStorage.setItem('colorScheme', value);
});

/* src/ui/Error.svelte generated by Svelte v3.55.1 */

function create_if_block$c(ctx) {
	let errormessage;
	let current;

	errormessage = new ErrorMessage({
			props: {
				title: /*$t*/ ctx[1]('error.title', { default: 'Error' }),
				details: /*$errorDetails*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(errormessage.$$.fragment);
		},
		m(target, anchor) {
			mount_component(errormessage, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const errormessage_changes = {};
			if (dirty & /*$t*/ 2) errormessage_changes.title = /*$t*/ ctx[1]('error.title', { default: 'Error' });
			if (dirty & /*$errorDetails*/ 1) errormessage_changes.details = /*$errorDetails*/ ctx[0];
			errormessage.$set(errormessage_changes);
		},
		i(local) {
			if (current) return;
			transition_in(errormessage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(errormessage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(errormessage, detaching);
		}
	};
}

function create_fragment$C(ctx) {
	let div;
	let current;
	let if_block = /*$errorDetails*/ ctx[0] && create_if_block$c(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "error");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*$errorDetails*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$errorDetails*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$c(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	let $errorDetails;
	let $t;
	component_subscribe($$self, errorDetails, $$value => $$invalidate(0, $errorDetails = $$value));
	const { t } = getContext('i18n');
	component_subscribe($$self, t, value => $$invalidate(1, $t = value));
	return [$errorDetails, $t, t];
}

class Error$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$t, create_fragment$C, safe_not_equal, {});
	}
}

/* src/ui/components/icons/Copy.svelte generated by Svelte v3.55.1 */

function create_fragment$B(ctx) {
	let svg;
	let rect;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr(rect, "x", "9");
			attr(rect, "y", "9");
			attr(rect, "width", "13");
			attr(rect, "height", "13");
			attr(rect, "rx", "2");
			attr(rect, "ry", "2");
			attr(path, "d", "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, rect);
			append(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class Copy extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$B, safe_not_equal, {});
	}
}

/* src/ui/components/icons/Check.svelte generated by Svelte v3.55.1 */

function create_fragment$A(ctx) {
	let svg;
	let polyline;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr(polyline, "points", "20 6 9 17 4 12");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class Check extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$A, safe_not_equal, {});
	}
}

/* src/ui/components/icons/CloseIcon.svelte generated by Svelte v3.55.1 */

function create_fragment$z(ctx) {
	let svg;
	let line0;
	let line1;

	return {
		c() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(line0, "x1", "18");
			attr(line0, "y1", "6");
			attr(line0, "x2", "6");
			attr(line0, "y2", "18");
			attr(line1, "x1", "6");
			attr(line1, "y1", "6");
			attr(line1, "x2", "18");
			attr(line1, "y2", "18");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, line0);
			append(svg, line1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class CloseIcon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$z, safe_not_equal, {});
	}
}

/* src/ui/components/icons/FileCode.svelte generated by Svelte v3.55.1 */

function create_fragment$y(ctx) {
	let svg;
	let path0;
	let polyline;
	let path1;
	let path2;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			polyline = svg_element("polyline");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4");
			attr(polyline, "points", "14 2 14 8 20 8");
			attr(path1, "d", "m9 18 3-3-3-3");
			attr(path2, "d", "m5 12-3 3 3 3");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, polyline);
			append(svg, path1);
			append(svg, path2);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class FileCode extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$y, safe_not_equal, {});
	}
}

/* src/ui/components/icons/Wharf.svelte generated by Svelte v3.55.1 */

function create_fragment$x(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			attr(path0, "d", "M35.54 18.77c-.019.989-.673 1.676-1.319 2.048l-1.388.802c-.663.383-1.438.531-2.132.531-.695 0-1.47-.148-2.132-.531l-1.362-.802v2.722c0 1.008-.664 1.711-1.318 2.089l-1.389.801c-.663.383-1.437.531-2.132.531-.694 0-1.469-.148-2.131-.53l-2.035-1.175-2.034 1.174c-.663.383-1.438.531-2.132.531-.694 0-1.469-.148-2.131-.53l-9.722-5.613c-.645-.372-1.3-1.06-1.317-2.049v-.061 3.626c.018.989.672 1.676 1.317 2.049l9.722 5.612c.662.382 1.437.53 2.131.53.694 0 1.47-.148 2.132-.53l2.034-1.175 2.035 1.175c.662.382 1.437.53 2.131.53.695 0 1.47-.148 2.132-.53l1.389-.802c.654-.378 1.318-1.08 1.318-2.088v-2.722l1.362.801c.663.383 1.437.531 2.132.531.694 0 1.469-.148 2.132-.53l1.388-.802c.646-.373 1.3-1.06 1.318-2.05V18.77Z");
			attr(path0, "fill", "#7BE7CE");
			attr(path1, "d", "M.874 15.362a1.5 1.5 0 0 0-.009.161v3.246c.019.99.673 1.677 1.318 2.05l9.722 5.612c.662.382 1.437.53 2.131.53.694 0 1.47-.148 2.132-.53l2.034-1.175 2.035 1.175c.662.382 1.437.53 2.131.53.695 0 1.47-.148 2.132-.53l1.389-.802c.654-.378 1.318-1.08 1.318-2.089V20.82l1.362.801c.663.383 1.437.531 2.132.531.694 0 1.469-.148 2.132-.53l1.388-.802c.646-.373 1.3-1.06 1.318-2.05v-3.564c-.018.99-.672 1.677-1.318 2.049l-1.388.802c-.663.382-1.438.53-2.132.53-.695 0-1.47-.148-2.132-.53l-1.388-.802a2.943 2.943 0 0 1-.067-.04 2.168 2.168 0 0 1 .085.834c.005.05.008.101.008.152v1.776c0 1.008-.664 1.71-1.318 2.088l-1.389.802c-.663.383-1.437.531-2.132.531-.694 0-1.469-.148-2.131-.53l-2.035-1.175-2.034 1.174c-.663.383-1.438.531-2.132.531-.694 0-1.469-.148-2.131-.53l-9.722-5.613c-.61-.352-1.229-.987-1.31-1.892ZM17.54 5.749l.004.043c.07.6.368 1.074.74 1.424a4.94 4.94 0 0 0-.75.045V5.875c0-.043.002-.085.006-.126Z");
			attr(path1, "fill", "#B2F2E1");
			attr(path2, "d", "m3.573 10.152-1.389.801c-.618.358-1.246 1.006-1.312 1.928a1.364 1.364 0 0 0-.007.136V15.204c.019.99.673 1.677 1.318 2.05l9.722 5.611c.662.383 1.437.532 2.131.532.694 0 1.47-.149 2.132-.532l2.034-1.174 2.035 1.174c.662.383 1.437.532 2.131.532.695 0 1.47-.149 2.132-.532l1.389-.801c.654-.378 1.318-1.08 1.318-2.089v-1.775c0-.052-.003-.102-.008-.153a2.25 2.25 0 0 0-.085-.833l.067.04 1.388.801c.663.383 1.437.531 2.132.531.694 0 1.469-.148 2.132-.53l1.388-.802c.646-.373 1.3-1.06 1.318-2.05v-2.092a2.359 2.359 0 0 0 0-.142V8.29l.001-.058c0-1.009-.664-1.711-1.318-2.089L24.501.531C23.838.15 23.064 0 22.369 0c-.694 0-1.469.149-2.131.531l-1.389.802c-.654.377-1.318 1.08-1.318 2.088 0 .048.001.095.004.14v1.847a2.069 2.069 0 0 0 .01.385c.069.6.367 1.073.739 1.423h-.08c-.695 0-1.47.148-2.133.53l-1.388.802c-.654.378-1.318 1.08-1.318 2.089 0 .065.002.13.008.193a1.485 1.485 0 0 0-.002.073v1.682l-.003.041-.002.045a2.298 2.298 0 0 0 .021.405c.017.112.041.22.072.322l-5.623-3.246C7.174 9.769 6.4 9.62 5.705 9.62c-.695 0-1.47.148-2.132.53Z");
			attr(path2, "fill", "#F4FAF4");
			attr(path3, "d", "M23.758 1.818c-.767-.442-2.01-.442-2.778 0l-1.389.802c-.766.443-.766 1.16 0 1.604l9.553 5.514c.369.213.575.501.575.802v.195c0 .3-.207.589-.575.801l-1.22.705c-.767.443-.767 1.16 0 1.603l1.389.802c.767.443 2.01.443 2.777 0l1.389-.802c.767-.443.767-1.16 0-1.603l-1.22-.705c-.369-.212-.576-.5-.576-.801v-.195c0-.3.207-.59.576-.802l1.22-.704c.767-.443.767-1.16 0-1.604l-9.721-5.612ZM7.093 11.439c-.767-.443-2.01-.443-2.777 0l-1.39.802c-.766.443-.766 1.16 0 1.603l9.722 5.612c.767.443 2.01.443 2.777 0l2.778-1.603-11.11-6.414Z");
			attr(path3, "fill", "#494E62");
			attr(path4, "d", "M23.351 15.545c0 .3.207.589.575.801l1.22.705c.767.443.767 1.16 0 1.603l-1.388.802c-.767.443-2.01.443-2.778 0l-2.777-1.603 2.609-1.507c.368-.212.575-.5.575-.801v-.195c0-.3-.207-.589-.575-.801l-5.387-3.11c-.767-.443-.767-1.16 0-1.603l1.39-.802c.766-.443 2.01-.443 2.776 0l5.555 3.207c.767.443.767 1.16 0 1.603l-1.22.705c-.368.212-.575.5-.575.801v.195Z");
			attr(path4, "fill", "#494E62");
			attr(svg, "width", "36");
			attr(svg, "height", "31");
			attr(svg, "fill", "none");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
			append(svg, path3);
			append(svg, path4);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let { size = '36px' } = $$props;

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
	};

	return [size];
}

class Wharf extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$s, create_fragment$x, safe_not_equal, { size: 0 });
	}
}

/* src/ui/components/icons/LogIn.svelte generated by Svelte v3.55.1 */

function create_fragment$w(ctx) {
	let svg;
	let path;
	let polyline;
	let line;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr(path, "d", "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4");
			attr(polyline, "points", "10 17 15 12 10 7");
			attr(line, "x1", "15");
			attr(line, "y1", "12");
			attr(line, "x2", "3");
			attr(line, "y2", "12");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, polyline);
			append(svg, line);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class LogIn extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$w, safe_not_equal, {});
	}
}

/* src/ui/components/icons/ChevronRight.svelte generated by Svelte v3.55.1 */

function create_fragment$v(ctx) {
	let svg;
	let polyline;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr(polyline, "points", "9 18 15 12 9 6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class ChevronRight extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$v, safe_not_equal, {});
	}
}

/* src/ui/components/icons/ChevronLeft.svelte generated by Svelte v3.55.1 */

function create_fragment$u(ctx) {
	let svg;
	let polyline;

	return {
		c() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr(polyline, "points", "15 18 9 12 15 6");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class ChevronLeft extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$u, safe_not_equal, {});
	}
}

/* src/ui/components/icons/Wallet.svelte generated by Svelte v3.55.1 */

function create_fragment$t(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr(path0, "d", "M20 12V8H6a2 2 0 0 1-2-2c0-1.1.9-2 2-2h12v4");
			attr(path1, "d", "M4 6v12c0 1.1.9 2 2 2h14v-4");
			attr(path2, "d", "M18 12a2 2 0 0 0-2 2c0 1.1.9 2 2 2h4v-4h-4z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path0);
			append(svg, path1);
			append(svg, path2);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class Wallet$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$t, safe_not_equal, {});
	}
}

/* src/ui/components/icons/Expand.svelte generated by Svelte v3.55.1 */

function create_fragment$s(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let line0;
	let line1;

	return {
		c() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(polyline0, "points", "15 3 21 3 21 9");
			attr(polyline1, "points", "9 21 3 21 3 15");
			attr(line0, "x1", "21");
			attr(line0, "y1", "3");
			attr(line0, "x2", "14");
			attr(line0, "y2", "10");
			attr(line1, "x1", "3");
			attr(line1, "y1", "21");
			attr(line1, "x2", "10");
			attr(line1, "y2", "14");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, polyline0);
			append(svg, polyline1);
			append(svg, line0);
			append(svg, line1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

class Expand extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$s, safe_not_equal, {});
	}
}

var icons = {
    copy: Copy,
    check: Check,
    close: CloseIcon,
    'file-code': FileCode,
    wharf: Wharf,
    login: LogIn,
    'chevron-right': ChevronRight,
    'chevron-left': ChevronLeft,
    wallet: Wallet$1,
    expand: Expand,
};

/* src/ui/components/Icon.svelte generated by Svelte v3.55.1 */

function create_fragment$r(ctx) {
	let div;
	let switch_instance;
	let current;
	const switch_instance_spread_levels = [/*$$props*/ ctx[2]];
	var switch_value = icons[/*name*/ ctx[0]];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props());
	}

	return {
		c() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			set_style(div, "width", "var(" + /*size*/ ctx[1] + ")");
			set_style(div, "display", "grid");
			set_style(div, "place-content", "center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (switch_instance) mount_component(switch_instance, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*$$props*/ 4)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*$$props*/ ctx[2])])
			: {};

			if (switch_value !== (switch_value = icons[/*name*/ ctx[0]])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty & /*size*/ 2) {
				set_style(div, "width", "var(" + /*size*/ ctx[1] + ")");
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (switch_instance) destroy_component(switch_instance);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let { name } = $$props;
	let { size = '--space-l' } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('name' in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
	};

	$$props = exclude_internal_props($$props);
	return [name, size, $$props];
}

class Icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$r, create_fragment$r, safe_not_equal, { name: 0, size: 1 });
	}
}

/* src/ui/components/Button.svelte generated by Svelte v3.55.1 */

function add_css$k(target) {
	append_styles(target, "svelte-hwtk1p", ".button.svelte-hwtk1p{--button-height:var(--space-2xl);cursor:pointer;display:flex;justify-content:center;align-items:center;gap:var(--space-2xs);height:var(--button-height);line-height:var(--button-height);text-decoration:none;text-align:center;border-radius:var(--border-radius-inner);font-size:var(--fs-1);font-weight:600;color:var(--button-color, var(--button-text-color));background:var(--button-background, var(--button-primary-background));border:none;box-shadow:var(--button-outline);flex:1}.button.svelte-hwtk1p:hover{background:var(--button-background-hover, var(--button-primary-background-hover));box-shadow:var(--button-outline-hover, var(--button-primary-outline-hover))}.button.svelte-hwtk1p:active{background:var(--button-background-active, var(--button-primary-background-active));box-shadow:var(--button-outline-active);color:var(--button-text-color-active)}.secondary.svelte-hwtk1p{--button-background:var(--button-secondary-background);--button-background-hover:var(--button-secondary-background-hover);--button-background-active:var(--button-secondary-background-active);--button-outline-hover:var(--button-secondary-outline-hover)}.outlined.svelte-hwtk1p{--button-background:transparent;--button-background-hover:transparent;--button-background-active:var(--button-outlined-background-active);--button-outline:var(--button-outlined-outline);--button-outline-hover:var(--button-outlined-outline-hover)}");
}

// (8:4) {#if icon}
function create_if_block$b(ctx) {
	let icon_1;
	let current;
	icon_1 = new Icon({ props: { name: /*icon*/ ctx[2] } });

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

function create_fragment$q(ctx) {
	let button;
	let t0;
	let span;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[2] && create_if_block$b(ctx);

	return {
		c() {
			button = element("button");
			if (if_block) if_block.c();
			t0 = space();
			span = element("span");
			span.textContent = `${/*label*/ ctx[1]}`;
			attr(button, "class", "button " + /*variant*/ ctx[4] + " svelte-hwtk1p");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if (if_block) if_block.m(button, null);
			append(button, t0);
			append(button, span);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "click", /*onClick*/ ctx[3]),
					listen(button, "keydown", function () {
						if (is_function(/*onKeydown*/ ctx[0])) /*onKeydown*/ ctx[0].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			if (/*icon*/ ctx[2]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$q($$self, $$props, $$invalidate) {
	let onKeydown;
	let { data } = $$props;
	const { label, icon, onClick, variant = 'primary' } = data;

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(5, data = $$props.data);
	};

	$$invalidate(0, onKeydown = onClick);
	return [onKeydown, label, icon, onClick, variant, data];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$q, create_fragment$q, safe_not_equal, { data: 5 }, add_css$k);
	}
}

/* src/ui/components/ButtonGroup.svelte generated by Svelte v3.55.1 */

function add_css$j(target) {
	append_styles(target, "svelte-1m2zvm", "div.svelte-1m2zvm{flex:1;display:flex;justify-content:space-between;gap:var(--space-xs)}");
}

function create_fragment$p(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "svelte-1m2zvm");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class ButtonGroup extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$p, create_fragment$p, safe_not_equal, {}, add_css$j);
	}
}

/* src/ui/components/Accept.svelte generated by Svelte v3.55.1 */

function create_default_slot$7(ctx) {
	let button0;
	let t_1;
	let button1;
	let current;

	button0 = new Button({
			props: {
				data: {
					variant: 'outlined',
					label: /*$t*/ ctx[0]('decline', { default: 'Decline' }),
					onClick: /*func*/ ctx[3],
					icon: 'close'
				}
			}
		});

	button1 = new Button({
			props: {
				data: {
					variant: 'primary',
					label: /*$t*/ ctx[0]('accept', { default: 'Accept' }),
					onClick: /*func_1*/ ctx[4],
					icon: 'check'
				}
			}
		});

	return {
		c() {
			create_component(button0.$$.fragment);
			t_1 = space();
			create_component(button1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t_1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$t*/ 1) button0_changes.data = {
				variant: 'outlined',
				label: /*$t*/ ctx[0]('decline', { default: 'Decline' }),
				onClick: /*func*/ ctx[3],
				icon: 'close'
			};

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$t*/ 1) button1_changes.data = {
				variant: 'primary',
				label: /*$t*/ ctx[0]('accept', { default: 'Accept' }),
				onClick: /*func_1*/ ctx[4],
				icon: 'check'
			};

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t_1);
			destroy_component(button1, detaching);
		}
	};
}

function create_fragment$o(ctx) {
	let buttongroup;
	let current;

	buttongroup = new ButtonGroup({
			props: {
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(buttongroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(buttongroup, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const buttongroup_changes = {};

			if (dirty & /*$$scope, $t*/ 33) {
				buttongroup_changes.$$scope = { dirty, ctx };
			}

			buttongroup.$set(buttongroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(buttongroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(buttongroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(buttongroup, detaching);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	let $t;
	const { t } = getContext('i18n');
	component_subscribe($$self, t, value => $$invalidate(0, $t = value));
	const dispatch = createEventDispatcher();
	const func = () => dispatch('cancel');
	const func_1 = () => dispatch('complete');
	return [$t, t, dispatch, func, func_1];
}

class Accept extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});
	}
}

/* src/ui/components/Asset.svelte generated by Svelte v3.55.1 */

function add_css$i(target) {
	append_styles(target, "svelte-1lmgxnd", ".asset.svelte-1lmgxnd.svelte-1lmgxnd{text-align:center}.asset.svelte-1lmgxnd>.svelte-1lmgxnd{margin:0;line-height:1.5}.value.svelte-1lmgxnd.svelte-1lmgxnd{font-size:var(--fs-2);font-weight:600;color:var(--body-text-color)}.label.svelte-1lmgxnd.svelte-1lmgxnd{font-size:var(--fs-0);font-weight:400;color:var(--body-text-color-variant)}");
}

// (8:0) {#if data}
function create_if_block$a(ctx) {
	let div;
	let p0;
	let t0_value = /*data*/ ctx[0].value + "";
	let t0;
	let t1;
	let p1;
	let t2_value = /*data*/ ctx[0].label + "";
	let t2;

	return {
		c() {
			div = element("div");
			p0 = element("p");
			t0 = text(t0_value);
			t1 = space();
			p1 = element("p");
			t2 = text(t2_value);
			attr(p0, "class", "value svelte-1lmgxnd");
			attr(p1, "class", "label svelte-1lmgxnd");
			attr(div, "class", "asset svelte-1lmgxnd");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p0);
			append(p0, t0);
			append(div, t1);
			append(div, p1);
			append(p1, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*data*/ ctx[0].value + "")) set_data(t0, t0_value);
			if (dirty & /*data*/ 1 && t2_value !== (t2_value = /*data*/ ctx[0].label + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$n(ctx) {
	let if_block_anchor;
	let if_block = /*data*/ ctx[0] && create_if_block$a(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*data*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	let { data = {
		label: '[[Unknown Label]]',
		value: '[[Unknown Value]]'
	} } = $$props;

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
	};

	return [data];
}

class Asset extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$n, create_fragment$n, safe_not_equal, { data: 0 }, add_css$i);
	}
}

/* src/ui/components/Close.svelte generated by Svelte v3.55.1 */

function add_css$h(target) {
	append_styles(target, "svelte-1bils14", "button.svelte-1bils14{cursor:pointer;display:block;width:300px;height:65px;border-radius:12px;font-size:16px;font-weight:600;color:var(--button-text-color);background-color:var(--button-tertiary-color);border:none;box-shadow:none;margin:27px auto 0}");
}

function create_fragment$m(ctx) {
	let button;
	let t_1_value = /*$t*/ ctx[0]('close', { default: 'Close' }) + "";
	let t_1;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t_1 = text(t_1_value);
			attr(button, "class", "svelte-1bils14");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t_1);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$t*/ 1 && t_1_value !== (t_1_value = /*$t*/ ctx[0]('close', { default: 'Close' }) + "")) set_data(t_1, t_1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let $t;
	const { t } = getContext('i18n');
	component_subscribe($$self, t, value => $$invalidate(0, $t = value));
	const dispatch = createEventDispatcher();
	const click_handler = () => dispatch('complete');
	return [$t, t, dispatch, click_handler];
}

class Close extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$m, create_fragment$m, safe_not_equal, {}, add_css$h);
	}
}

/* src/ui/components/Link.svelte generated by Svelte v3.55.1 */

function add_css$g(target) {
	append_styles(target, "svelte-785ja0", ".button.svelte-785ja0{--button-height:var(--space-2xl);cursor:pointer;display:flex;justify-content:center;align-items:center;gap:var(--space-2xs);height:var(--button-height);line-height:var(--button-height);text-decoration:none;text-align:center;border-radius:var(--border-radius-inner);font-size:var(--fs-1);font-weight:600;color:var(--button-color, var(--button-text-color));background:var(--button-background, var(--button-primary-background));border:none;box-shadow:var(--button-outline);flex:1}.button.svelte-785ja0:hover{background:var(--button-background-hover, var(--button-primary-background-hover));box-shadow:var(--button-outline-hover, var(--button-primary-outline-hover))}.button.svelte-785ja0:active{background:var(--button-background-active, var(--button-primary-background-active));box-shadow:var(--button-outline-active);color:var(--button-text-color-active)}.outlined.svelte-785ja0{--button-background:transparent;--button-background-hover:transparent;--button-background-active:var(--button-outlined-background-active);--button-outline:var(--button-outlined-outline);--button-outline-hover:var(--button-outlined-outline-hover)}a.svelte-785ja0{align-self:stretch}");
}

// (7:4) {#if icon}
function create_if_block$9(ctx) {
	let icon_1;
	let current;
	icon_1 = new Icon({ props: { name: /*icon*/ ctx[3] } });

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

function create_fragment$l(ctx) {
	let a;
	let t0;
	let span;
	let current;
	let if_block = /*icon*/ ctx[3] && create_if_block$9(ctx);

	return {
		c() {
			a = element("a");
			if (if_block) if_block.c();
			t0 = space();
			span = element("span");
			span.textContent = `${/*label*/ ctx[2]}`;
			attr(a, "class", "outlined svelte-785ja0");
			attr(a, "href", /*href*/ ctx[1]);
			attr(a, "target", "_blank");
			attr(a, "rel", "noreferrer");
			toggle_class(a, "button", /*button*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			if (if_block) if_block.m(a, null);
			append(a, t0);
			append(a, span);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*icon*/ ctx[3]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (if_block) if_block.d();
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { data } = $$props;
	let { button = true, href, label, icon } = data;

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(4, data = $$props.data);
	};

	return [button, href, label, icon, data];
}

class Link extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$l, create_fragment$l, safe_not_equal, { data: 4 }, add_css$g);
	}
}

/* src/ui/components/Countdown.svelte generated by Svelte v3.55.1 */

function create_if_block$8(ctx) {
	let previous_key = /*remaining*/ ctx[1];
	let key_block_anchor;
	let key_block = create_key_block(ctx);

	return {
		c() {
			key_block.c();
			key_block_anchor = empty();
		},
		m(target, anchor) {
			key_block.m(target, anchor);
			insert(target, key_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*remaining*/ 2 && safe_not_equal(previous_key, previous_key = /*remaining*/ ctx[1])) {
				key_block.d(1);
				key_block = create_key_block(ctx);
				key_block.c();
				key_block.m(key_block_anchor.parentNode, key_block_anchor);
			} else {
				key_block.p(ctx, dirty);
			}
		},
		d(detaching) {
			if (detaching) detach(key_block_anchor);
			key_block.d(detaching);
		}
	};
}

// (40:4) {#key remaining}
function create_key_block(ctx) {
	let t_value = countdownFormat(/*deadline*/ ctx[0]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*deadline*/ 1 && t_value !== (t_value = countdownFormat(/*deadline*/ ctx[0]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$k(ctx) {
	let if_block_anchor;
	let if_block = /*deadline*/ ctx[0] && create_if_block$8(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*deadline*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function countdownFormat(date) {
	const timeLeft = date.getTime() - Date.now();

	if (timeLeft > 0) {
		return new Date(timeLeft).toISOString().substr(14, 5);
	}

	return '00:00';
}

function instance$k($$self, $$props, $$invalidate) {
	let { data = '' } = $$props;
	let deadline;
	let remaining;
	let timer;

	onDestroy(() => {
		if (timer) {
			clearInterval(timer);
		}
	});

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(2, data = $$props.data);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*timer, data, deadline, remaining*/ 15) {
			{
				if (timer) {
					clearInterval(timer);
				}

				$$invalidate(0, deadline = new Date(data));

				$$invalidate(3, timer = setInterval(
					() => {
						$$invalidate(1, remaining = deadline - Date.now());

						if (remaining <= 0) {
							clearInterval(timer);
						}
					},
					200
				));
			}
		}
	};

	return [deadline, remaining, data, timer];
}

class Countdown extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$k, create_fragment$k, safe_not_equal, { data: 2 });
	}
}

var ErrorCorrectLevel = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2,
};

var Mode = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3,
};

class QR8bitByte {
    constructor(data) {
        this.mode = Mode.MODE_8BIT_BYTE;
        this.data = data;
    }
    getLength() {
        return this.data.length;
    }
    write(buffer) {
        for (let i = 0; i < this.data.length; i++) {
            // not JIS ...
            buffer.put(this.data.charCodeAt(i), 8);
        }
    }
}

class QRBitBuffer {
    constructor() {
        this.buffer = [];
        this.length = 0;
    }
    get(index) {
        const bufIndex = Math.floor(index / 8);
        return ((this.buffer[bufIndex] >>> (7 - (index % 8))) & 1) == 1;
    }
    put(num, length) {
        for (let i = 0; i < length; i++) {
            this.putBit(((num >>> (length - i - 1)) & 1) == 1);
        }
    }
    getLengthInBits() {
        return this.length;
    }
    putBit(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
        }
        if (bit) {
            this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
        }
        this.length++;
    }
}

const QRMath = {
    glog: function (n) {
        if (n < 1) {
            throw new Error('glog(' + n + ')');
        }
        return QRMath.LOG_TABLE[n];
    },
    gexp: function (n) {
        while (n < 0) {
            n += 255;
        }
        while (n >= 256) {
            n -= 255;
        }
        return QRMath.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256),
};
for (let i = 0; i < 8; i++) {
    QRMath.EXP_TABLE[i] = 1 << i;
}
for (let i = 8; i < 256; i++) {
    QRMath.EXP_TABLE[i] =
        QRMath.EXP_TABLE[i - 4] ^
            QRMath.EXP_TABLE[i - 5] ^
            QRMath.EXP_TABLE[i - 6] ^
            QRMath.EXP_TABLE[i - 8];
}
for (let i = 0; i < 255; i++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
}

class QRPolynomial {
    constructor(num, shift) {
        if (num.length == undefined) {
            throw new Error(num.length + '/' + shift);
        }
        let offset = 0;
        while (offset < num.length && num[offset] == 0) {
            offset++;
        }
        this.num = new Array(num.length - offset + shift);
        for (let i = 0; i < num.length - offset; i++) {
            this.num[i] = num[i + offset];
        }
    }
    get(index) {
        return this.num[index];
    }
    getLength() {
        return this.num.length;
    }
    multiply(e) {
        const num = new Array(this.getLength() + e.getLength() - 1);
        for (let i = 0; i < this.getLength(); i++) {
            for (let j = 0; j < e.getLength(); j++) {
                num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
            }
        }
        return new QRPolynomial(num, 0);
    }
    mod(e) {
        if (this.getLength() - e.getLength() < 0) {
            return this;
        }
        const ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
        const num = new Array(this.getLength());
        for (let i = 0; i < this.getLength(); i++) {
            num[i] = this.get(i);
        }
        for (let i = 0; i < e.getLength(); i++) {
            num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
        }
        // recursive call
        return new QRPolynomial(num, 0).mod(e);
    }
}

// ErrorCorrectLevel
class QRRSBlock {
    constructor(totalCount, dataCount) {
        this.totalCount = totalCount;
        this.dataCount = dataCount;
    }
    static getRSBlocks(typeNumber, errorCorrectLevel) {
        const rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
        if (rsBlock == undefined) {
            throw new Error('bad rs block @ typeNumber:' +
                typeNumber +
                '/errorCorrectLevel:' +
                errorCorrectLevel);
        }
        const length = rsBlock.length / 3;
        const list = [];
        for (let i = 0; i < length; i++) {
            const count = rsBlock[i * 3 + 0];
            const totalCount = rsBlock[i * 3 + 1];
            const dataCount = rsBlock[i * 3 + 2];
            for (let j = 0; j < count; j++) {
                list.push(new QRRSBlock(totalCount, dataCount));
            }
        }
        return list;
    }
    static getRsBlockTable(typeNumber, errorCorrectLevel) {
        switch (errorCorrectLevel) {
            case ErrorCorrectLevel.L:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
            case ErrorCorrectLevel.M:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
            case ErrorCorrectLevel.Q:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
            case ErrorCorrectLevel.H:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
            default:
                return undefined;
        }
    }
}
QRRSBlock.RS_BLOCK_TABLE = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16],
];

const QRMaskPattern = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
};
const QRUtil = {
    PATTERN_POSITION_TABLE: [
        [],
        [6, 18],
        [6, 22],
        [6, 26],
        [6, 30],
        [6, 34],
        [6, 22, 38],
        [6, 24, 42],
        [6, 26, 46],
        [6, 28, 50],
        [6, 30, 54],
        [6, 32, 58],
        [6, 34, 62],
        [6, 26, 46, 66],
        [6, 26, 48, 70],
        [6, 26, 50, 74],
        [6, 30, 54, 78],
        [6, 30, 56, 82],
        [6, 30, 58, 86],
        [6, 34, 62, 90],
        [6, 28, 50, 72, 94],
        [6, 26, 50, 74, 98],
        [6, 30, 54, 78, 102],
        [6, 28, 54, 80, 106],
        [6, 32, 58, 84, 110],
        [6, 30, 58, 86, 114],
        [6, 34, 62, 90, 118],
        [6, 26, 50, 74, 98, 122],
        [6, 30, 54, 78, 102, 126],
        [6, 26, 52, 78, 104, 130],
        [6, 30, 56, 82, 108, 134],
        [6, 34, 60, 86, 112, 138],
        [6, 30, 58, 86, 114, 142],
        [6, 34, 62, 90, 118, 146],
        [6, 30, 54, 78, 102, 126, 150],
        [6, 24, 50, 76, 102, 128, 154],
        [6, 28, 54, 80, 106, 132, 158],
        [6, 32, 58, 84, 110, 136, 162],
        [6, 26, 54, 82, 110, 138, 166],
        [6, 30, 58, 86, 114, 142, 170],
    ],
    G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
    G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
    G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
    getBCHTypeInfo: function (data) {
        let d = data << 10;
        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
            d ^= QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15));
        }
        return ((data << 10) | d) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function (data) {
        let d = data << 12;
        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
            d ^= QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18));
        }
        return (data << 12) | d;
    },
    getBCHDigit: function (data) {
        let digit = 0;
        while (data != 0) {
            digit++;
            data >>>= 1;
        }
        return digit;
    },
    getPatternPosition: function (typeNumber) {
        return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    getMask: function (maskPattern, i, j) {
        switch (maskPattern) {
            case QRMaskPattern.PATTERN000:
                return (i + j) % 2 == 0;
            case QRMaskPattern.PATTERN001:
                return i % 2 == 0;
            case QRMaskPattern.PATTERN010:
                return j % 3 == 0;
            case QRMaskPattern.PATTERN011:
                return (i + j) % 3 == 0;
            case QRMaskPattern.PATTERN100:
                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
            case QRMaskPattern.PATTERN101:
                return ((i * j) % 2) + ((i * j) % 3) == 0;
            case QRMaskPattern.PATTERN110:
                return (((i * j) % 2) + ((i * j) % 3)) % 2 == 0;
            case QRMaskPattern.PATTERN111:
                return (((i * j) % 3) + ((i + j) % 2)) % 2 == 0;
            default:
                throw new Error('bad maskPattern:' + maskPattern);
        }
    },
    getErrorCorrectPolynomial: function (errorCorrectLength) {
        let a = new QRPolynomial([1], 0);
        for (let i = 0; i < errorCorrectLength; i++) {
            a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
        }
        return a;
    },
    getLengthInBits: function (mode, type) {
        if (1 <= type && type < 10) {
            // 1 - 9
            switch (mode) {
                case Mode.MODE_NUMBER:
                    return 10;
                case Mode.MODE_ALPHA_NUM:
                    return 9;
                case Mode.MODE_8BIT_BYTE:
                    return 8;
                case Mode.MODE_KANJI:
                    return 8;
                default:
                    throw new Error('mode:' + mode);
            }
        }
        else if (type < 27) {
            // 10 - 26
            switch (mode) {
                case Mode.MODE_NUMBER:
                    return 12;
                case Mode.MODE_ALPHA_NUM:
                    return 11;
                case Mode.MODE_8BIT_BYTE:
                    return 16;
                case Mode.MODE_KANJI:
                    return 10;
                default:
                    throw new Error('mode:' + mode);
            }
        }
        else if (type < 41) {
            // 27 - 40
            switch (mode) {
                case Mode.MODE_NUMBER:
                    return 14;
                case Mode.MODE_ALPHA_NUM:
                    return 13;
                case Mode.MODE_8BIT_BYTE:
                    return 16;
                case Mode.MODE_KANJI:
                    return 12;
                default:
                    throw new Error('mode:' + mode);
            }
        }
        else {
            throw new Error('type:' + type);
        }
    },
    getLostPoint: function (qrCode) {
        const moduleCount = qrCode.getModuleCount();
        let lostPoint = 0;
        // LEVEL1
        for (let row = 0; row < moduleCount; row++) {
            for (let col = 0; col < moduleCount; col++) {
                let sameCount = 0;
                const dark = qrCode.isDark(row, col);
                for (let r = -1; r <= 1; r++) {
                    if (row + r < 0 || moduleCount <= row + r) {
                        continue;
                    }
                    for (let c = -1; c <= 1; c++) {
                        if (col + c < 0 || moduleCount <= col + c) {
                            continue;
                        }
                        if (r == 0 && c == 0) {
                            continue;
                        }
                        if (dark == qrCode.isDark(row + r, col + c)) {
                            sameCount++;
                        }
                    }
                }
                if (sameCount > 5) {
                    lostPoint += 3 + sameCount - 5;
                }
            }
        }
        // LEVEL2
        for (let row = 0; row < moduleCount - 1; row++) {
            for (let col = 0; col < moduleCount - 1; col++) {
                let count = 0;
                if (qrCode.isDark(row, col))
                    count++;
                if (qrCode.isDark(row + 1, col))
                    count++;
                if (qrCode.isDark(row, col + 1))
                    count++;
                if (qrCode.isDark(row + 1, col + 1))
                    count++;
                if (count == 0 || count == 4) {
                    lostPoint += 3;
                }
            }
        }
        // LEVEL3
        for (let row = 0; row < moduleCount; row++) {
            for (let col = 0; col < moduleCount - 6; col++) {
                if (qrCode.isDark(row, col) &&
                    !qrCode.isDark(row, col + 1) &&
                    qrCode.isDark(row, col + 2) &&
                    qrCode.isDark(row, col + 3) &&
                    qrCode.isDark(row, col + 4) &&
                    !qrCode.isDark(row, col + 5) &&
                    qrCode.isDark(row, col + 6)) {
                    lostPoint += 40;
                }
            }
        }
        for (let col = 0; col < moduleCount; col++) {
            for (let row = 0; row < moduleCount - 6; row++) {
                if (qrCode.isDark(row, col) &&
                    !qrCode.isDark(row + 1, col) &&
                    qrCode.isDark(row + 2, col) &&
                    qrCode.isDark(row + 3, col) &&
                    qrCode.isDark(row + 4, col) &&
                    !qrCode.isDark(row + 5, col) &&
                    qrCode.isDark(row + 6, col)) {
                    lostPoint += 40;
                }
            }
        }
        // LEVEL4
        let darkCount = 0;
        for (let col = 0; col < moduleCount; col++) {
            for (let row = 0; row < moduleCount; row++) {
                if (qrCode.isDark(row, col)) {
                    darkCount++;
                }
            }
        }
        const ratio = Math.abs((100 * darkCount) / moduleCount / moduleCount - 50) / 5;
        lostPoint += ratio * 10;
        return lostPoint;
    },
};

class QRCode {
    constructor(typeNumber, errorCorrectLevel) {
        this.typeNumber = typeNumber;
        this.errorCorrectLevel = errorCorrectLevel;
        this.modules = null;
        this.moduleCount = 0;
        this.dataCache = null;
        this.dataList = [];
    }
    addData(data) {
        const newData = new QR8bitByte(data);
        this.dataList.push(newData);
        this.dataCache = null;
    }
    isDark(row, col) {
        if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
            throw new Error(row + ',' + col);
        }
        return this.modules[row][col];
    }
    getModuleCount() {
        return this.moduleCount;
    }
    make() {
        // Calculate automatically typeNumber if provided is < 1
        if (this.typeNumber < 1) {
            let typeNumber = 1;
            for (typeNumber = 1; typeNumber < 40; typeNumber++) {
                const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
                const buffer = new QRBitBuffer();
                let totalDataCount = 0;
                for (let i = 0; i < rsBlocks.length; i++) {
                    totalDataCount += rsBlocks[i].dataCount;
                }
                for (let i = 0; i < this.dataList.length; i++) {
                    const data = this.dataList[i];
                    buffer.put(data.mode, 4);
                    buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
                    data.write(buffer);
                }
                if (buffer.getLengthInBits() <= totalDataCount * 8)
                    break;
            }
            this.typeNumber = typeNumber;
        }
        this.makeImpl(false, this.getBestMaskPattern());
    }
    makeImpl(test, maskPattern) {
        this.moduleCount = this.typeNumber * 4 + 17;
        this.modules = new Array(this.moduleCount);
        for (let row = 0; row < this.moduleCount; row++) {
            this.modules[row] = new Array(this.moduleCount);
            for (let col = 0; col < this.moduleCount; col++) {
                this.modules[row][col] = null; //(col + row) % 3;
            }
        }
        this.setupPositionProbePattern(0, 0);
        this.setupPositionProbePattern(this.moduleCount - 7, 0);
        this.setupPositionProbePattern(0, this.moduleCount - 7);
        this.setupPositionAdjustPattern();
        this.setupTimingPattern();
        this.setupTypeInfo(test, maskPattern);
        if (this.typeNumber >= 7) {
            this.setupTypeNumber(test);
        }
        if (this.dataCache == null) {
            this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
        }
        this.mapData(this.dataCache, maskPattern);
    }
    setupPositionProbePattern(row, col) {
        for (let r = -1; r <= 7; r++) {
            if (row + r <= -1 || this.moduleCount <= row + r)
                continue;
            for (let c = -1; c <= 7; c++) {
                if (col + c <= -1 || this.moduleCount <= col + c)
                    continue;
                if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
                    (0 <= c && c <= 6 && (r == 0 || r == 6)) ||
                    (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                    this.modules[row + r][col + c] = true;
                }
                else {
                    this.modules[row + r][col + c] = false;
                }
            }
        }
    }
    getBestMaskPattern() {
        let minLostPoint = 0;
        let pattern = 0;
        for (let i = 0; i < 8; i++) {
            this.makeImpl(true, i);
            const lostPoint = QRUtil.getLostPoint(this);
            if (i == 0 || minLostPoint > lostPoint) {
                minLostPoint = lostPoint;
                pattern = i;
            }
        }
        return pattern;
    }
    setupTimingPattern() {
        for (let r = 8; r < this.moduleCount - 8; r++) {
            if (this.modules[r][6] != null) {
                continue;
            }
            this.modules[r][6] = r % 2 == 0;
        }
        for (let c = 8; c < this.moduleCount - 8; c++) {
            if (this.modules[6][c] != null) {
                continue;
            }
            this.modules[6][c] = c % 2 == 0;
        }
    }
    setupPositionAdjustPattern() {
        const pos = QRUtil.getPatternPosition(this.typeNumber);
        for (let i = 0; i < pos.length; i++) {
            for (let j = 0; j < pos.length; j++) {
                const row = pos[i];
                const col = pos[j];
                if (this.modules[row][col] != null) {
                    continue;
                }
                for (let r = -2; r <= 2; r++) {
                    for (let c = -2; c <= 2; c++) {
                        if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
                            this.modules[row + r][col + c] = true;
                        }
                        else {
                            this.modules[row + r][col + c] = false;
                        }
                    }
                }
            }
        }
    }
    setupTypeNumber(test) {
        const bits = QRUtil.getBCHTypeNumber(this.typeNumber);
        for (let i = 0; i < 18; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            this.modules[Math.floor(i / 3)][(i % 3) + this.moduleCount - 8 - 3] = mod;
        }
        for (let i = 0; i < 18; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            this.modules[(i % 3) + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
        }
    }
    setupTypeInfo(test, maskPattern) {
        const data = (this.errorCorrectLevel << 3) | maskPattern;
        const bits = QRUtil.getBCHTypeInfo(data);
        // vertical
        for (let i = 0; i < 15; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            if (i < 6) {
                this.modules[i][8] = mod;
            }
            else if (i < 8) {
                this.modules[i + 1][8] = mod;
            }
            else {
                this.modules[this.moduleCount - 15 + i][8] = mod;
            }
        }
        // horizontal
        for (let i = 0; i < 15; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            if (i < 8) {
                this.modules[8][this.moduleCount - i - 1] = mod;
            }
            else if (i < 9) {
                this.modules[8][15 - i - 1 + 1] = mod;
            }
            else {
                this.modules[8][15 - i - 1] = mod;
            }
        }
        // fixed module
        this.modules[this.moduleCount - 8][8] = !test;
    }
    mapData(data, maskPattern) {
        let inc = -1;
        let row = this.moduleCount - 1;
        let bitIndex = 7;
        let byteIndex = 0;
        for (let col = this.moduleCount - 1; col > 0; col -= 2) {
            if (col == 6)
                col--;
            for (;;) {
                for (let c = 0; c < 2; c++) {
                    if (this.modules[row][col - c] == null) {
                        let dark = false;
                        if (byteIndex < data.length) {
                            dark = ((data[byteIndex] >>> bitIndex) & 1) == 1;
                        }
                        const mask = QRUtil.getMask(maskPattern, row, col - c);
                        if (mask) {
                            dark = !dark;
                        }
                        this.modules[row][col - c] = dark;
                        bitIndex--;
                        if (bitIndex == -1) {
                            byteIndex++;
                            bitIndex = 7;
                        }
                    }
                }
                row += inc;
                if (row < 0 || this.moduleCount <= row) {
                    row -= inc;
                    inc = -inc;
                    break;
                }
            }
        }
    }
    static createData(typeNumber, errorCorrectLevel, dataList) {
        const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
        const buffer = new QRBitBuffer();
        for (let i = 0; i < dataList.length; i++) {
            const data = dataList[i];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
        }
        // calc num max data.
        let totalDataCount = 0;
        for (let i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
        }
        if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw new Error('code length overflow. (' +
                buffer.getLengthInBits() +
                '>' +
                totalDataCount * 8 +
                ')');
        }
        // end code
        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
        }
        // padding
        while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
        }
        // padding
        for (;;) {
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
                break;
            }
            buffer.put(QRCode.PAD0, 8);
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
                break;
            }
            buffer.put(QRCode.PAD1, 8);
        }
        return QRCode.createBytes(buffer, rsBlocks);
    }
    static createBytes(buffer, rsBlocks) {
        let offset = 0;
        let maxDcCount = 0;
        let maxEcCount = 0;
        const dcdata = new Array(rsBlocks.length);
        const ecdata = new Array(rsBlocks.length);
        for (let r = 0; r < rsBlocks.length; r++) {
            const dcCount = rsBlocks[r].dataCount;
            const ecCount = rsBlocks[r].totalCount - dcCount;
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
            dcdata[r] = new Array(dcCount);
            for (let i = 0; i < dcdata[r].length; i++) {
                dcdata[r][i] = 0xff & buffer.buffer[i + offset];
            }
            offset += dcCount;
            const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
            const modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (let i = 0; i < ecdata[r].length; i++) {
                const modIndex = i + modPoly.getLength() - ecdata[r].length;
                ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
            }
        }
        let totalCodeCount = 0;
        for (let i = 0; i < rsBlocks.length; i++) {
            totalCodeCount += rsBlocks[i].totalCount;
        }
        const data = new Array(totalCodeCount);
        let index = 0;
        for (let i = 0; i < maxDcCount; i++) {
            for (let r = 0; r < rsBlocks.length; r++) {
                if (i < dcdata[r].length) {
                    data[index++] = dcdata[r][i];
                }
            }
        }
        for (let i = 0; i < maxEcCount; i++) {
            for (let r = 0; r < rsBlocks.length; r++) {
                if (i < ecdata[r].length) {
                    data[index++] = ecdata[r][i];
                }
            }
        }
        return data;
    }
}
QRCode.PAD0 = 0xec;
QRCode.PAD1 = 0x11;

/**
 * Generate QR SVG
 * @author Johan Nordberg <code@johan-nordberg.com>
 */
function generate(text, level = 'L', version = -1) {
    const qr = new QRCode(version, ErrorCorrectLevel[level]);
    const rects = [];
    qr.addData(text);
    qr.make();
    const rows = qr.modules;
    const size = rows.length;
    for (const [y, row] of rows.entries()) {
        let rect;
        for (const [x, on] of row.entries()) {
            if (on) {
                if (!rect)
                    rect = { x, y, width: 0, height: 1 };
                rect.width++;
            }
            else {
                if (rect && rect.width > 0) {
                    rects.push(rect);
                }
                rect = undefined;
            }
        }
        if (rect && rect.width > 0) {
            rects.push(rect);
        }
    }
    const svg = [
        `<svg xmlns="http://www.w3.org/2000/svg" width="300" viewBox="0 0 ${size} ${size}">`,
    ];
    for (const { x, y, width, height } of rects) {
        svg.push(`<rect x="${x}" y="${y}" width="${width}" height="${height}" />`);
    }
    svg.push('</svg>');
    return svg.join('');
}

/* src/ui/components/Qr.svelte generated by Svelte v3.55.1 */

function add_css$f(target) {
	append_styles(target, "svelte-1wvj6y8", "div.svelte-1wvj6y8{position:relative;display:grid;background:var(--body-background-color);border-radius:var(--space-s);padding:var(--space-s);border:1px solid var(--qr-border-color);aspect-ratio:1;align-self:stretch}span.svelte-1wvj6y8{background:white;padding:var(--space-xs);border-radius:var(--space-2xs);transition:scale 200ms ease;z-index:2}span.svelte-1wvj6y8 svg{width:100%;height:100%}");
}

// (14:0) {#if data}
function create_if_block$7(ctx) {
	let div;
	let span;
	let raw_value = generate(/*data*/ ctx[0]) + "";
	let span_style_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			span = element("span");
			attr(span, "style", span_style_value = /*expanded*/ ctx[1] ? expandedStyles : '');
			attr(span, "class", "svelte-1wvj6y8");
			attr(div, "class", "svelte-1wvj6y8");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			span.innerHTML = raw_value;

			if (!mounted) {
				dispose = [
					listen(span, "click", /*collapse*/ ctx[2]),
					listen(span, "keydown", /*collapse*/ ctx[2])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 1 && raw_value !== (raw_value = generate(/*data*/ ctx[0]) + "")) span.innerHTML = raw_value;
			if (dirty & /*expanded*/ 2 && span_style_value !== (span_style_value = /*expanded*/ ctx[1] ? expandedStyles : '')) {
				attr(span, "style", span_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$j(ctx) {
	let if_block_anchor;
	let if_block = /*data*/ ctx[0] && create_if_block$7(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*data*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const expandedStyles = 'scale: 2; transform-origin: center;';

function instance$j($$self, $$props, $$invalidate) {
	let { data = '' } = $$props;
	let expanded = false;

	const collapse = () => {
		$$invalidate(1, expanded = false);
	};

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
	};

	return [data, expanded, collapse];
}

class Qr extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { data: 0 }, add_css$f);
	}
}

/* src/ui/components/Textarea.svelte generated by Svelte v3.55.1 */

function add_css$e(target) {
	append_styles(target, "svelte-1j7j5xe", "div.svelte-1j7j5xe{display:flex;background-color:var(--text-area-background);padding:var(--space-m);border-radius:var(--border-radius-inner)}textarea.svelte-1j7j5xe{flex:1;color:var(--text-area-text-color);background-color:var(--text-area-background);border:none;font-size:var(--fs-0);font-weight:600;line-height:1.5;resize:none;opacity:0.75}");
}

function create_fragment$i(ctx) {
	let div;
	let textarea;
	let textarea_value_value;

	return {
		c() {
			div = element("div");
			textarea = element("textarea");
			attr(textarea, "rows", "10");
			textarea.readOnly = true;
			textarea.value = textarea_value_value = /*data*/ ctx[0].content;
			attr(textarea, "class", "svelte-1j7j5xe");
			attr(div, "class", "svelte-1j7j5xe");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, textarea);
		},
		p(ctx, [dirty]) {
			if (dirty & /*data*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[0].content)) {
				textarea.value = textarea_value_value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { data = {} } = $$props;

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
	};

	return [data];
}

class Textarea extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { data: 0 }, add_css$e);
	}
}

/* src/ui/components/BodyTitle.svelte generated by Svelte v3.55.1 */

function add_css$d(target) {
	append_styles(target, "svelte-18rgh1v", "h3.svelte-18rgh1v{color:var(--body-text-color);font-size:var(--fs-2);font-weight:600;text-align:center;margin:0}");
}

function create_fragment$h(ctx) {
	let h3;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			h3 = element("h3");
			if (default_slot) default_slot.c();
			attr(h3, "class", "svelte-18rgh1v");
		},
		m(target, anchor) {
			insert(target, h3, anchor);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h3);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class BodyTitle extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$h, create_fragment$h, safe_not_equal, {}, add_css$d);
	}
}

/* src/ui/components/BodyText.svelte generated by Svelte v3.55.1 */

function add_css$c(target) {
	append_styles(target, "svelte-9xif45", "p.svelte-9xif45{color:var(--body-text-color-variant);font-size:var(--fs-1);font-weight:400;text-align:center;margin:0}");
}

function create_fragment$g(ctx) {
	let p;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			attr(p, "class", "svelte-9xif45");
		},
		m(target, anchor) {
			insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class BodyText extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$g, create_fragment$g, safe_not_equal, {}, add_css$c);
	}
}

/* src/ui/Prompt.svelte generated by Svelte v3.55.1 */

function add_css$b(target) {
	append_styles(target, "svelte-zwsiaf", "div.svelte-zwsiaf{display:flex;flex-direction:column;gap:var(--space-m);gap:var(--space-l)}.text.svelte-zwsiaf{gap:var(--space-s)}");
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (104:8) <BodyTitle>
function create_default_slot_1$4(ctx) {
	let t_value = /*$prompt*/ ctx[0]?.args.title + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$prompt*/ 1 && t_value !== (t_value = /*$prompt*/ ctx[0]?.args.title + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (105:8) <BodyText>
function create_default_slot$6(ctx) {
	let t_value = /*$prompt*/ ctx[0]?.args.body + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$prompt*/ 1 && t_value !== (t_value = /*$prompt*/ ctx[0]?.args.body + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (107:4) {#each $elements as component}
function create_each_block$3(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*component*/ ctx[6].props];
	var switch_value = /*component*/ ctx[6].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props());
		switch_instance.$on("complete", /*complete_handler*/ ctx[4]);
		switch_instance.$on("cancel", /*cancel_handler*/ ctx[5]);
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty & /*$elements*/ 2)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*component*/ ctx[6].props)])
			: {};

			if (switch_value !== (switch_value = /*component*/ ctx[6].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props());
					switch_instance.$on("complete", /*complete_handler*/ ctx[4]);
					switch_instance.$on("cancel", /*cancel_handler*/ ctx[5]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment$f(ctx) {
	let div1;
	let div0;
	let bodytitle;
	let t0;
	let bodytext;
	let t1;
	let current;

	bodytitle = new BodyTitle({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		});

	bodytext = new BodyText({
			props: {
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	let each_value = /*$elements*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(bodytitle.$$.fragment);
			t0 = space();
			create_component(bodytext.$$.fragment);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "text svelte-zwsiaf");
			attr(div1, "class", "svelte-zwsiaf");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(bodytitle, div0, null);
			append(div0, t0);
			mount_component(bodytext, div0, null);
			append(div1, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const bodytitle_changes = {};

			if (dirty & /*$$scope, $prompt*/ 513) {
				bodytitle_changes.$$scope = { dirty, ctx };
			}

			bodytitle.$set(bodytitle_changes);
			const bodytext_changes = {};

			if (dirty & /*$$scope, $prompt*/ 513) {
				bodytext_changes.$$scope = { dirty, ctx };
			}

			bodytext.$set(bodytext_changes);

			if (dirty & /*$elements, dispatch*/ 10) {
				each_value = /*$elements*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(bodytitle.$$.fragment, local);
			transition_in(bodytext.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(bodytitle.$$.fragment, local);
			transition_out(bodytext.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(bodytitle);
			destroy_component(bodytext);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let $prompt;
	let $elements;
	component_subscribe($$self, prompt, $$value => $$invalidate(0, $prompt = $$value));

	const elements = derived(prompt, $prompt => {
		const components = [];

		if ($prompt) {
			$prompt.args.elements.forEach(element => {
				switch (element.type) {
					case 'accept':
						{
							components.push({
								component: Accept,
								props: { data: element.data }
							});

							break;
						}
					case 'asset':
						{
							components.push({
								component: Asset,
								props: { data: element.data }
							});

							break;
						}
					case 'close':
						{
							components.push({
								component: Close,
								props: { label: element.label }
							});

							break;
						}
					case 'link':
						{
							components.push({
								component: Link,
								props: { data: element.data }
							});

							break;
						}
					case 'qr':
						{
							components.push({
								component: Qr,
								props: { data: element.data }
							});

							break;
						}
					case 'countdown':
						{
							components.push({
								component: Countdown,
								props: { data: element.data }
							});

							break;
						}
					case 'textarea':
						{
							components.push({
								component: Textarea,
								props: { data: element.data }
							});

							break;
						}
					case 'button':
						{
							components.push({
								component: Button,
								props: { data: element.data }
							});

							break;
						}
					default:
						{
							throw new Error(`Unknown element type: ${element.type}`);
						}
				}
			});
		}

		return components;
	});

	component_subscribe($$self, elements, value => $$invalidate(1, $elements = value));
	const dispatch = createEventDispatcher();
	const complete_handler = () => dispatch('complete');
	const cancel_handler = () => dispatch('cancel');
	return [$prompt, $elements, elements, dispatch, complete_handler, cancel_handler];
}

class Prompt extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, {}, add_css$b);
	}
}

/* src/ui/components/List.svelte generated by Svelte v3.55.1 */

function add_css$a(target) {
	append_styles(target, "svelte-1q25md2", "ul.svelte-1q25md2{list-style:none;padding:0;margin:0}");
}

function create_fragment$e(ctx) {
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr(ul, "class", "svelte-1q25md2");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class List extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, {}, add_css$a);
	}
}

/* src/ui/components/ListItem.svelte generated by Svelte v3.55.1 */

function add_css$9(target) {
	append_styles(target, "svelte-1dwmlhd", "li.svelte-1dwmlhd.svelte-1dwmlhd{display:flex}li.svelte-1dwmlhd:not(:last-child) button.svelte-1dwmlhd{border-bottom:1px solid var(--list-divider-color)}li.svelte-1dwmlhd button.svelte-1dwmlhd{flex:1;display:flex;align-items:center;cursor:pointer;border:none;background:none;color:var(--body-text-color);font-size:var(--fs-1);font-weight:500;padding-block:var(--space-s)}.leading.svelte-1dwmlhd>.svelte-1dwmlhd{display:grid;place-content:center;inline-size:var(--space-xl)}.leading.svelte-1dwmlhd img.svelte-1dwmlhd{max-inline-size:30px;max-block-size:30px;object-fit:contain}.trailing.svelte-1dwmlhd.svelte-1dwmlhd{opacity:0.2}li.svelte-1dwmlhd button.svelte-1dwmlhd:hover{background:var(--list-item-background-color-hover)}li.svelte-1dwmlhd button:hover .trailing.svelte-1dwmlhd{opacity:1}span.svelte-1dwmlhd.svelte-1dwmlhd{flex:1;text-align:start;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-inline-start:var(--space-xs)}");
}

// (16:34) 
function create_if_block_2$3(ctx) {
	let div;
	let icon;
	let current;
	icon = new Icon({ props: { name: /*leadingIcon*/ ctx[2] } });

	return {
		c() {
			div = element("div");
			create_component(icon.$$.fragment);
			attr(div, "class", "icon svelte-1dwmlhd");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*leadingIcon*/ 4) icon_changes.name = /*leadingIcon*/ ctx[2];
			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(icon);
		}
	};
}

// (12:12) {#if logo}
function create_if_block_1$4(ctx) {
	let div;
	let img;
	let img_src_value;
	let img_alt_value;

	return {
		c() {
			div = element("div");
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*logo*/ ctx[4])) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = `${/*label*/ ctx[0]} logo`);
			attr(img, "class", "svelte-1dwmlhd");
			attr(div, "class", "logo svelte-1dwmlhd");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
		},
		p(ctx, dirty) {
			if (dirty & /*logo*/ 16 && !src_url_equal(img.src, img_src_value = /*logo*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*label*/ 1 && img_alt_value !== (img_alt_value = `${/*label*/ ctx[0]} logo`)) {
				attr(img, "alt", img_alt_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (25:8) {#if trailingIcon}
function create_if_block$6(ctx) {
	let div;
	let icon;
	let current;
	icon = new Icon({ props: { name: /*trailingIcon*/ ctx[3] } });

	return {
		c() {
			div = element("div");
			create_component(icon.$$.fragment);
			attr(div, "class", "trailing svelte-1dwmlhd");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*trailingIcon*/ 8) icon_changes.name = /*trailingIcon*/ ctx[3];
			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(icon);
		}
	};
}

function create_fragment$d(ctx) {
	let li;
	let button;
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let span;
	let t1;
	let t2;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$4, create_if_block_2$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*logo*/ ctx[4]) return 0;
		if (/*leadingIcon*/ ctx[2]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block1 = /*trailingIcon*/ ctx[3] && create_if_block$6(ctx);

	return {
		c() {
			li = element("li");
			button = element("button");
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			t1 = text(/*label*/ ctx[0]);
			t2 = space();
			if (if_block1) if_block1.c();
			attr(div, "class", "leading svelte-1dwmlhd");
			attr(span, "class", "svelte-1dwmlhd");
			attr(button, "class", "svelte-1dwmlhd");
			attr(li, "class", "svelte-1dwmlhd");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			append(button, div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			append(button, t0);
			append(button, span);
			append(span, t1);
			append(button, t2);
			if (if_block1) if_block1.m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*onClick*/ ctx[1])) /*onClick*/ ctx[1].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block0) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(div, null);
				} else {
					if_block0 = null;
				}
			}

			if (!current || dirty & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);

			if (/*trailingIcon*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*trailingIcon*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { label } = $$props;
	let { onClick } = $$props;
	let { leadingIcon = undefined } = $$props;
	let { trailingIcon = 'chevron-right' } = $$props;
	let { logo = undefined } = $$props;

	$$self.$$set = $$props => {
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('onClick' in $$props) $$invalidate(1, onClick = $$props.onClick);
		if ('leadingIcon' in $$props) $$invalidate(2, leadingIcon = $$props.leadingIcon);
		if ('trailingIcon' in $$props) $$invalidate(3, trailingIcon = $$props.trailingIcon);
		if ('logo' in $$props) $$invalidate(4, logo = $$props.logo);
	};

	return [label, onClick, leadingIcon, trailingIcon, logo];
}

class ListItem extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$d,
			create_fragment$d,
			safe_not_equal,
			{
				label: 0,
				onClick: 1,
				leadingIcon: 2,
				trailingIcon: 3,
				logo: 4
			},
			add_css$9
		);
	}
}

/* src/ui/login/Blockchain.svelte generated by Svelte v3.55.1 */

function add_css$8(target) {
	append_styles(target, "svelte-1d8fcdl", "section.svelte-1d8fcdl{display:flex;flex-direction:column;gap:var(--space-s)}");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (12:0) {#if chains}
function create_if_block$5(ctx) {
	let section;
	let bodytitle;
	let t;
	let list;
	let current;

	bodytitle = new BodyTitle({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	list = new List({
			props: {
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			section = element("section");
			create_component(bodytitle.$$.fragment);
			t = space();
			create_component(list.$$.fragment);
			attr(section, "class", "svelte-1d8fcdl");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			mount_component(bodytitle, section, null);
			append(section, t);
			mount_component(list, section, null);
			current = true;
		},
		p(ctx, dirty) {
			const bodytitle_changes = {};

			if (dirty & /*$$scope, title*/ 130) {
				bodytitle_changes.$$scope = { dirty, ctx };
			}

			bodytitle.$set(bodytitle_changes);
			const list_changes = {};

			if (dirty & /*$$scope, chains*/ 129) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i(local) {
			if (current) return;
			transition_in(bodytitle.$$.fragment, local);
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(bodytitle.$$.fragment, local);
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section);
			destroy_component(bodytitle);
			destroy_component(list);
		}
	};
}

// (14:8) <BodyTitle>
function create_default_slot_1$3(ctx) {
	let t;

	return {
		c() {
			t = text(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data(t, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (16:12) {#each chains as chain}
function create_each_block$2(ctx) {
	let listitem;
	let current;

	function func() {
		return /*func*/ ctx[3](/*chain*/ ctx[4]);
	}

	listitem = new ListItem({
			props: {
				label: /*chain*/ ctx[4].name,
				onClick: func,
				leadingIcon: "wharf",
				logo: getThemedLogo(/*chain*/ ctx[4])
			}
		});

	return {
		c() {
			create_component(listitem.$$.fragment);
		},
		m(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const listitem_changes = {};
			if (dirty & /*chains*/ 1) listitem_changes.label = /*chain*/ ctx[4].name;
			if (dirty & /*chains*/ 1) listitem_changes.onClick = func;
			if (dirty & /*chains*/ 1) listitem_changes.logo = getThemedLogo(/*chain*/ ctx[4]);
			listitem.$set(listitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(listitem, detaching);
		}
	};
}

// (15:8) <List>
function create_default_slot$5(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*chains*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*chains, dispatch, getThemedLogo*/ 5) {
				each_value = /*chains*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$c(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*chains*/ ctx[0] && create_if_block$5(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*chains*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*chains*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { chains } = $$props;
	let { title } = $$props;
	const dispatch = createEventDispatcher();
	const func = chain => dispatch('select', chain.id);

	$$self.$$set = $$props => {
		if ('chains' in $$props) $$invalidate(0, chains = $$props.chains);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
	};

	return [chains, title, dispatch, func];
}

class Blockchain extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { chains: 0, title: 1 }, add_css$8);
	}
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

let GetAccountsByAuthorizersRow = class GetAccountsByAuthorizersRow extends Struct {
};
__decorate([
    Struct.field(Name)
], GetAccountsByAuthorizersRow.prototype, "account_name", void 0);
__decorate([
    Struct.field(Name)
], GetAccountsByAuthorizersRow.prototype, "permission_name", void 0);
__decorate([
    Struct.field(PublicKey)
], GetAccountsByAuthorizersRow.prototype, "authorizing_key", void 0);
__decorate([
    Struct.field(Weight)
], GetAccountsByAuthorizersRow.prototype, "weight", void 0);
__decorate([
    Struct.field(UInt32)
], GetAccountsByAuthorizersRow.prototype, "threshold", void 0);
GetAccountsByAuthorizersRow = __decorate([
    Struct.type('get_accounts_by_authorizers')
], GetAccountsByAuthorizersRow);
let GetAccountsByAuthorizers = class GetAccountsByAuthorizers extends Struct {
};
__decorate([
    Struct.field(GetAccountsByAuthorizersRow, { array: true })
], GetAccountsByAuthorizers.prototype, "accounts", void 0);
GetAccountsByAuthorizers = __decorate([
    Struct.type('get_accounts_by_authorizers')
], GetAccountsByAuthorizers);

/* src/ui/components/TextInput.svelte generated by Svelte v3.55.1 */

function add_css$7(target) {
	append_styles(target, "svelte-3b7p6", "input.svelte-3b7p6{box-sizing:border-box;height:var(--space-2xl);border-radius:var(--border-radius-inner);border:1px solid var(--input-border-color);padding-inline:var(--space-m);color:var(--body-text-color);background-color:var(--body-background-color);font-size:var(--fs-1)}input.svelte-3b7p6::placeholder{font-size:var(--fs-1);color:var(--input-placeholder-color);font-style:italic}input.svelte-3b7p6:hover{border:1px solid transparent;outline:2px solid var(--input-border-color-hover);background-color:var(--input-background-focus)}input.svelte-3b7p6:focus-within{border:1px solid transparent;outline:2px solid var(--input-border-color-focus);background-color:var(--input-background-focus)}input.error.svelte-3b7p6{border:1px solid var(--error-color);color:var(--error-color)}input.error.svelte-3b7p6:focus-within{border:1px solid transparent;color:var(--body-text-color)}");
}

function create_fragment$b(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			input.autofocus = /*autofocus*/ ctx[3];
			attr(input, "type", "text");
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			attr(input, "class", "svelte-3b7p6");
			toggle_class(input, "error", /*error*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			if (/*autofocus*/ ctx[3]) input.focus();

			if (!mounted) {
				dispose = [
					listen(input, "keyup", prevent_default(function () {
						if (is_function(/*onKeyup*/ ctx[2])) /*onKeyup*/ ctx[2].apply(this, arguments);
					})),
					listen(input, "input", /*input_input_handler*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*autofocus*/ 8) {
				input.autofocus = /*autofocus*/ ctx[3];
			}

			if (dirty & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*error*/ 16) {
				toggle_class(input, "error", /*error*/ ctx[4]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { value } = $$props;
	let { placeholder } = $$props;
	let { onKeyup } = $$props;
	let { autofocus = false } = $$props;
	let { error = false } = $$props;

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
		if ('onKeyup' in $$props) $$invalidate(2, onKeyup = $$props.onKeyup);
		if ('autofocus' in $$props) $$invalidate(3, autofocus = $$props.autofocus);
		if ('error' in $$props) $$invalidate(4, error = $$props.error);
	};

	return [value, placeholder, onKeyup, autofocus, error, input_input_handler];
}

class TextInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$b,
			create_fragment$b,
			safe_not_equal,
			{
				value: 0,
				placeholder: 1,
				onKeyup: 2,
				autofocus: 3,
				error: 4
			},
			add_css$7
		);
	}
}

/* src/ui/components/WarningMessage.svelte generated by Svelte v3.55.1 */

function add_css$6(target) {
	append_styles(target, "svelte-3zo29t", "div.svelte-3zo29t{display:flex;flex-direction:column;align-items:center;gap:var(--space-s);text-align:center;color:var(--body-text-color);margin-block:var(--space-s)}svg.svelte-3zo29t{--size:var(--space-3xl);width:var(--size);height:var(--size)}h2.svelte-3zo29t{font-size:var(--fs-3);font-weight:600;margin:0}p.svelte-3zo29t{font-size:var(--fs-1);font-weight:400;margin:0;max-width:var(--measure);overflow-wrap:anywhere}");
}

function create_fragment$a(ctx) {
	let div;
	let svg;
	let circle;
	let line0;
	let line1;
	let t0;
	let h2;
	let t1;
	let t2;
	let p;
	let t3;

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			t0 = space();
			h2 = element("h2");
			t1 = text(/*title*/ ctx[0]);
			t2 = space();
			p = element("p");
			t3 = text(/*details*/ ctx[1]);
			attr(circle, "cx", "12");
			attr(circle, "cy", "12");
			attr(circle, "r", "10");
			attr(line0, "x1", "12");
			attr(line0, "y1", "8");
			attr(line0, "x2", "12");
			attr(line0, "y2", "12");
			attr(line1, "x1", "12");
			attr(line1, "y1", "16");
			attr(line1, "x2", "12.01");
			attr(line1, "y2", "16");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", "svelte-3zo29t");
			attr(h2, "class", "svelte-3zo29t");
			attr(p, "class", "svelte-3zo29t");
			attr(div, "class", "svelte-3zo29t");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);
			append(svg, circle);
			append(svg, line0);
			append(svg, line1);
			append(div, t0);
			append(div, h2);
			append(h2, t1);
			append(div, t2);
			append(div, p);
			append(p, t3);
		},
		p(ctx, [dirty]) {
			if (dirty & /*title*/ 1) set_data(t1, /*title*/ ctx[0]);
			if (dirty & /*details*/ 2) set_data(t3, /*details*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { details } = $$props;

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('details' in $$props) $$invalidate(1, details = $$props.details);
	};

	return [title, details];
}

class WarningMessage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { title: 0, details: 1 }, add_css$6);
	}
}

/* src/ui/login/Permission.svelte generated by Svelte v3.55.1 */

function add_css$5(target) {
	append_styles(target, "svelte-13p224c", "section.svelte-13p224c{display:flex;flex-direction:column;gap:var(--space-s)}p.loading.svelte-13p224c{margin:0;text-align:center;height:var(--space-4xl)}p.error.svelte-13p224c{margin:0;text-align:center;color:var(--error-color)}.input-group.svelte-13p224c{display:flex;flex-direction:column;gap:var(--space-m);margin-top:var(--space-s)}");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	return child_ctx;
}

// (67:4) <BodyTitle>
function create_default_slot_1$2(ctx) {
	let t_1;

	return {
		c() {
			t_1 = text(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t_1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data(t_1, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t_1);
		}
	};
}

// (89:27) 
function create_if_block_3$2(ctx) {
	let div;
	let textinput;
	let updating_value;
	let t0;
	let t1;
	let button;
	let current;

	function textinput_value_binding(value) {
		/*textinput_value_binding*/ ctx[16](value);
	}

	let textinput_props = {
		onKeyup: /*handleKeyup*/ ctx[13],
		placeholder: "Account name",
		autofocus: !/*input*/ ctx[2],
		error: /*accountNotFound*/ ctx[5] && /*input*/ ctx[2] === /*prevInput*/ ctx[3]
	};

	if (/*input*/ ctx[2] !== void 0) {
		textinput_props.value = /*input*/ ctx[2];
	}

	textinput = new TextInput({ props: textinput_props });
	binding_callbacks.push(() => bind(textinput, 'value', textinput_value_binding));
	let if_block = /*accountNotFound*/ ctx[5] && create_if_block_4$2(ctx);

	button = new Button({
			props: {
				data: {
					variant: 'primary',
					onClick: /*lookup*/ ctx[12],
					label: /*$t*/ ctx[8]('login.enter.lookup', { default: 'Lookup Account' })
				}
			}
		});

	return {
		c() {
			div = element("div");
			create_component(textinput.$$.fragment);
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(button.$$.fragment);
			attr(div, "class", "input-group svelte-13p224c");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(textinput, div, null);
			append(div, t0);
			if (if_block) if_block.m(div, null);
			append(div, t1);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*input*/ 4) textinput_changes.autofocus = !/*input*/ ctx[2];
			if (dirty & /*accountNotFound, input, prevInput*/ 44) textinput_changes.error = /*accountNotFound*/ ctx[5] && /*input*/ ctx[2] === /*prevInput*/ ctx[3];

			if (!updating_value && dirty & /*input*/ 4) {
				updating_value = true;
				textinput_changes.value = /*input*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			textinput.$set(textinput_changes);

			if (/*accountNotFound*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$2(ctx);
					if_block.c();
					if_block.m(div, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const button_changes = {};

			if (dirty & /*$t*/ 256) button_changes.data = {
				variant: 'primary',
				onClick: /*lookup*/ ctx[12],
				label: /*$t*/ ctx[8]('login.enter.lookup', { default: 'Lookup Account' })
			};

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(textinput);
			if (if_block) if_block.d();
			destroy_component(button);
		}
	};
}

// (79:46) 
function create_if_block_2$2(ctx) {
	let warningmessage;
	let current;

	warningmessage = new WarningMessage({
			props: {
				title: /*$t*/ ctx[8]('login.select.no_accounts', { default: 'No accounts found' }),
				details: /*$t*/ ctx[8]('login.select.no_match', {
					default: 'No accounts found matching {{publicKey}}',
					publicKey: /*walletPlugin*/ ctx[0].metadata.publicKey
				})
			}
		});

	return {
		c() {
			create_component(warningmessage.$$.fragment);
		},
		m(target, anchor) {
			mount_component(warningmessage, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const warningmessage_changes = {};
			if (dirty & /*$t*/ 256) warningmessage_changes.title = /*$t*/ ctx[8]('login.select.no_accounts', { default: 'No accounts found' });

			if (dirty & /*$t, walletPlugin*/ 257) warningmessage_changes.details = /*$t*/ ctx[8]('login.select.no_match', {
				default: 'No accounts found matching {{publicKey}}',
				publicKey: /*walletPlugin*/ ctx[0].metadata.publicKey
			});

			warningmessage.$set(warningmessage_changes);
		},
		i(local) {
			if (current) return;
			transition_in(warningmessage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(warningmessage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(warningmessage, detaching);
		}
	};
}

// (70:52) 
function create_if_block_1$3(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(list.$$.fragment);
		},
		m(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const list_changes = {};

			if (dirty & /*$$scope, permissions*/ 1048640) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(list, detaching);
		}
	};
}

// (68:4) {#if $busy}
function create_if_block$4(ctx) {
	let p;
	let t_1_value = /*$t*/ ctx[8]('loading', { default: 'Loading...' }) + "";
	let t_1;

	return {
		c() {
			p = element("p");
			t_1 = text(t_1_value);
			attr(p, "class", "loading svelte-13p224c");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t_1);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 256 && t_1_value !== (t_1_value = /*$t*/ ctx[8]('loading', { default: 'Loading...' }) + "")) set_data(t_1, t_1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (98:12) {#if accountNotFound}
function create_if_block_4$2(ctx) {
	let p;
	let t0_value = /*$t*/ ctx[8]('login.enter.not_found', { default: 'Unable to find account' }) + "";
	let t0;
	let t1;
	let t2;

	return {
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(/*prevInput*/ ctx[3]);
			attr(p, "class", "error svelte-13p224c");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 256 && t0_value !== (t0_value = /*$t*/ ctx[8]('login.enter.not_found', { default: 'Unable to find account' }) + "")) set_data(t0, t0_value);
			if (dirty & /*prevInput*/ 8) set_data(t2, /*prevInput*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (72:12) {#each permissions as permission}
function create_each_block$1(ctx) {
	let listitem;
	let current;

	function func() {
		return /*func*/ ctx[15](/*permission*/ ctx[17]);
	}

	listitem = new ListItem({
			props: {
				label: String(/*permission*/ ctx[17]),
				onClick: func
			}
		});

	return {
		c() {
			create_component(listitem.$$.fragment);
		},
		m(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const listitem_changes = {};
			if (dirty & /*permissions*/ 64) listitem_changes.label = String(/*permission*/ ctx[17]);
			if (dirty & /*permissions*/ 64) listitem_changes.onClick = func;
			listitem.$set(listitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(listitem, detaching);
		}
	};
}

// (71:8) <List>
function create_default_slot$4(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*permissions*/ ctx[6];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*String, permissions, dispatch*/ 1088) {
				each_value = /*permissions*/ ctx[6];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$9(ctx) {
	let section;
	let bodytitle;
	let t_1;
	let current_block_type_index;
	let if_block;
	let current;

	bodytitle = new BodyTitle({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	const if_block_creators = [create_if_block$4, create_if_block_1$3, create_if_block_2$2, create_if_block_3$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$busy*/ ctx[7]) return 0;
		if (/*permissions*/ ctx[6] && /*permissions*/ ctx[6].length > 0) return 1;
		if (/*walletPlugin*/ ctx[0].metadata.publicKey) return 2;
		if (!/*accountName*/ ctx[4]) return 3;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			section = element("section");
			create_component(bodytitle.$$.fragment);
			t_1 = space();
			if (if_block) if_block.c();
			attr(section, "class", "svelte-13p224c");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			mount_component(bodytitle, section, null);
			append(section, t_1);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(section, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const bodytitle_changes = {};

			if (dirty & /*$$scope, title*/ 1048578) {
				bodytitle_changes.$$scope = { dirty, ctx };
			}

			bodytitle.$set(bodytitle_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(section, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(bodytitle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(bodytitle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section);
			destroy_component(bodytitle);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let $busy;
	let $t;
	const { t } = getContext('i18n');
	component_subscribe($$self, t, value => $$invalidate(8, $t = value));
	let { client } = $$props;
	let { walletPlugin } = $$props;
	let { title } = $$props;
	const dispatch = createEventDispatcher();
	let busy = writable(true);
	component_subscribe($$self, busy, value => $$invalidate(7, $busy = value));
	let input = '';
	let prevInput = '';
	let accountName;
	let accountNotFound = false;
	let permissions;

	onMount(async () => {
		if (walletPlugin.config.requiresPermissionSelect) {
			const response = await client.call({
				path: '/v1/chain/get_accounts_by_authorizers',
				params: { keys: [walletPlugin.metadata.publicKey] }
			});

			busy.set(false);
			$$invalidate(6, permissions = response.accounts.map(account => PermissionLevel.from(`${account.account_name}@${account.permission_name}`)));
		} else if (walletPlugin.config.requiresPermissionEntry) {
			busy.set(false);
			$$invalidate(6, permissions = []);
		}
	});

	async function lookup() {
		busy.set(true);

		try {
			const response = await client.v1.chain.get_account(input);

			if (response.account_name.equals(input)) {
				$$invalidate(4, accountName = response.account_name);
				$$invalidate(6, permissions = response.permissions.map(permission => PermissionLevel.from(`${response.account_name}@${permission.perm_name}`)));
			}

			$$invalidate(5, accountNotFound = false);
		} catch(error) {
			$$invalidate(5, accountNotFound = true);
		} finally {
			$$invalidate(3, prevInput = input);
			busy.set(false);
		}
	}

	function handleKeyup(event) {
		if (event.code == 'Enter') {
			event.preventDefault();
			lookup();
			return false;
		}
	}

	const func = permission => dispatch('select', permission);

	function textinput_value_binding(value) {
		input = value;
		$$invalidate(2, input);
	}

	$$self.$$set = $$props => {
		if ('client' in $$props) $$invalidate(14, client = $$props.client);
		if ('walletPlugin' in $$props) $$invalidate(0, walletPlugin = $$props.walletPlugin);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
	};

	return [
		walletPlugin,
		title,
		input,
		prevInput,
		accountName,
		accountNotFound,
		permissions,
		$busy,
		$t,
		t,
		dispatch,
		busy,
		lookup,
		handleKeyup,
		client,
		func,
		textinput_value_binding
	];
}

class Permission extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { client: 14, walletPlugin: 0, title: 1 }, add_css$5);
	}
}

/* src/ui/login/Wallet.svelte generated by Svelte v3.55.1 */

function add_css$4(target) {
	append_styles(target, "svelte-lwrp5l", "section.svelte-lwrp5l{display:flex;flex-direction:column;gap:var(--space-s)}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

// (12:0) {#if wallets}
function create_if_block$3(ctx) {
	let section;
	let bodytitle;
	let t;
	let list;
	let current;

	bodytitle = new BodyTitle({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	list = new List({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			section = element("section");
			create_component(bodytitle.$$.fragment);
			t = space();
			create_component(list.$$.fragment);
			attr(section, "class", "svelte-lwrp5l");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			mount_component(bodytitle, section, null);
			append(section, t);
			mount_component(list, section, null);
			current = true;
		},
		p(ctx, dirty) {
			const bodytitle_changes = {};

			if (dirty & /*$$scope, title*/ 130) {
				bodytitle_changes.$$scope = { dirty, ctx };
			}

			bodytitle.$set(bodytitle_changes);
			const list_changes = {};

			if (dirty & /*$$scope, wallets*/ 129) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i(local) {
			if (current) return;
			transition_in(bodytitle.$$.fragment, local);
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(bodytitle.$$.fragment, local);
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section);
			destroy_component(bodytitle);
			destroy_component(list);
		}
	};
}

// (14:8) <BodyTitle>
function create_default_slot_1$1(ctx) {
	let t;

	return {
		c() {
			t = text(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data(t, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (16:12) {#each wallets as wallet, index}
function create_each_block(ctx) {
	let listitem;
	let current;

	function func() {
		return /*func*/ ctx[3](/*index*/ ctx[6]);
	}

	listitem = new ListItem({
			props: {
				label: /*wallet*/ ctx[4].metadata.name,
				onClick: func,
				leadingIcon: "wallet",
				logo: getThemedLogo(/*wallet*/ ctx[4].metadata)
			}
		});

	return {
		c() {
			create_component(listitem.$$.fragment);
		},
		m(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const listitem_changes = {};
			if (dirty & /*wallets*/ 1) listitem_changes.label = /*wallet*/ ctx[4].metadata.name;
			if (dirty & /*wallets*/ 1) listitem_changes.logo = getThemedLogo(/*wallet*/ ctx[4].metadata);
			listitem.$set(listitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(listitem, detaching);
		}
	};
}

// (15:8) <List>
function create_default_slot$3(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*wallets*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*wallets, dispatch, getThemedLogo*/ 5) {
				each_value = /*wallets*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$8(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*wallets*/ ctx[0] && create_if_block$3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*wallets*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*wallets*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { wallets } = $$props;
	let { title } = $$props;
	const dispatch = createEventDispatcher();
	const func = index => dispatch('select', index);

	$$self.$$set = $$props => {
		if ('wallets' in $$props) $$invalidate(0, wallets = $$props.wallets);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
	};

	return [wallets, title, dispatch, func];
}

class Wallet extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { wallets: 0, title: 1 }, add_css$4);
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}

/* src/ui/components/Transition.svelte generated by Svelte v3.55.1 */

function create_fragment$7(ctx) {
	let div;
	let div_intro;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "transition");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fly, { duration: 200, x: /*direction*/ ctx[0] });
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { direction = 0 } = $$props;

	$$self.$$set = $$props => {
		if ('direction' in $$props) $$invalidate(0, direction = $$props.direction);
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [direction, $$scope, slots];
}

class Transition extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { direction: 0 });
	}
}

/* src/ui/Login.svelte generated by Svelte v3.55.1 */

function create_else_block_1(ctx) {
	let p;
	let t_1_value = /*$t*/ ctx[3]('loading', { default: 'Loading...' }) + "";
	let t_1;

	return {
		c() {
			p = element("p");
			t_1 = text(t_1_value);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t_1);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 8 && t_1_value !== (t_1_value = /*$t*/ ctx[3]('loading', { default: 'Loading...' }) + "")) set_data(t_1, t_1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (153:0) {#if $props && $loginContext}
function create_if_block$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_1$2,
		create_if_block_2$1,
		create_if_block_3$1,
		create_if_block_4$1,
		create_else_block$1
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*$step*/ ctx[5] === /*Steps*/ ctx[0].selectWallet) return 0;
		if (/*$step*/ ctx[5] === /*Steps*/ ctx[0].selectChain && /*$chains*/ ctx[6]) return 1;
		if (/*$step*/ ctx[5] === /*Steps*/ ctx[0].enterPermission && /*$client*/ ctx[7] && /*$walletPlugin*/ ctx[8]) return 2;
		if (/*$step*/ ctx[5] === /*Steps*/ ctx[0].selectPermission && /*$client*/ ctx[7] && /*$walletPlugin*/ ctx[8]) return 3;
		return 4;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (192:4) {:else}
function create_else_block$1(ctx) {
	let p;

	let t_1_value = /*$t*/ ctx[3]('login.complete', {
		default: 'Complete the login using your selected wallet.'
	}) + "";

	let t_1;

	return {
		c() {
			p = element("p");
			t_1 = text(t_1_value);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t_1);
		},
		p(ctx, dirty) {
			if (dirty & /*$t*/ 8 && t_1_value !== (t_1_value = /*$t*/ ctx[3]('login.complete', {
				default: 'Complete the login using your selected wallet.'
			}) + "")) set_data(t_1, t_1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (182:75) 
function create_if_block_4$1(ctx) {
	let transition;
	let current;

	transition = new Transition({
			props: {
				direction: /*transitionDirection*/ ctx[1],
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(transition.$$.fragment);
		},
		m(target, anchor) {
			mount_component(transition, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const transition_changes = {};
			if (dirty & /*transitionDirection*/ 2) transition_changes.direction = /*transitionDirection*/ ctx[1];

			if (dirty & /*$$scope, $client, $walletPlugin, $t*/ 536871304) {
				transition_changes.$$scope = { dirty, ctx };
			}

			transition.$set(transition_changes);
		},
		i(local) {
			if (current) return;
			transition_in(transition.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(transition.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(transition, detaching);
		}
	};
}

// (172:74) 
function create_if_block_3$1(ctx) {
	let transition;
	let current;

	transition = new Transition({
			props: {
				direction: /*transitionDirection*/ ctx[1],
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(transition.$$.fragment);
		},
		m(target, anchor) {
			mount_component(transition, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const transition_changes = {};
			if (dirty & /*transitionDirection*/ 2) transition_changes.direction = /*transitionDirection*/ ctx[1];

			if (dirty & /*$$scope, $client, $walletPlugin, $t*/ 536871304) {
				transition_changes.$$scope = { dirty, ctx };
			}

			transition.$set(transition_changes);
		},
		i(local) {
			if (current) return;
			transition_in(transition.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(transition.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(transition, detaching);
		}
	};
}

// (163:53) 
function create_if_block_2$1(ctx) {
	let transition;
	let current;

	transition = new Transition({
			props: {
				direction: /*transitionDirection*/ ctx[1],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(transition.$$.fragment);
		},
		m(target, anchor) {
			mount_component(transition, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const transition_changes = {};
			if (dirty & /*transitionDirection*/ 2) transition_changes.direction = /*transitionDirection*/ ctx[1];

			if (dirty & /*$$scope, $chains, $t*/ 536870984) {
				transition_changes.$$scope = { dirty, ctx };
			}

			transition.$set(transition_changes);
		},
		i(local) {
			if (current) return;
			transition_in(transition.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(transition.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(transition, detaching);
		}
	};
}

// (154:4) {#if $step === Steps.selectWallet}
function create_if_block_1$2(ctx) {
	let transition;
	let current;

	transition = new Transition({
			props: {
				direction: /*transitionDirection*/ ctx[1],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(transition.$$.fragment);
		},
		m(target, anchor) {
			mount_component(transition, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const transition_changes = {};
			if (dirty & /*transitionDirection*/ 2) transition_changes.direction = /*transitionDirection*/ ctx[1];

			if (dirty & /*$$scope, $loginContext, $t*/ 536870924) {
				transition_changes.$$scope = { dirty, ctx };
			}

			transition.$set(transition_changes);
		},
		i(local) {
			if (current) return;
			transition_in(transition.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(transition.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(transition, detaching);
		}
	};
}

// (183:8) <Transition direction={transitionDirection}>
function create_default_slot_3(ctx) {
	let permission;
	let current;

	permission = new Permission({
			props: {
				client: /*$client*/ ctx[7],
				walletPlugin: /*$walletPlugin*/ ctx[8],
				title: /*$t*/ ctx[3]('login.select.account', { default: 'Select an Account' })
			}
		});

	permission.$on("select", /*selectPermission*/ ctx[16]);
	permission.$on("cancel", /*unselectChain*/ ctx[15]);

	return {
		c() {
			create_component(permission.$$.fragment);
		},
		m(target, anchor) {
			mount_component(permission, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const permission_changes = {};
			if (dirty & /*$client*/ 128) permission_changes.client = /*$client*/ ctx[7];
			if (dirty & /*$walletPlugin*/ 256) permission_changes.walletPlugin = /*$walletPlugin*/ ctx[8];
			if (dirty & /*$t*/ 8) permission_changes.title = /*$t*/ ctx[3]('login.select.account', { default: 'Select an Account' });
			permission.$set(permission_changes);
		},
		i(local) {
			if (current) return;
			transition_in(permission.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(permission.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(permission, detaching);
		}
	};
}

// (173:8) <Transition direction={transitionDirection}>
function create_default_slot_2(ctx) {
	let permission;
	let current;

	permission = new Permission({
			props: {
				client: /*$client*/ ctx[7],
				walletPlugin: /*$walletPlugin*/ ctx[8],
				title: /*$t*/ ctx[3]('login.enter.account', { default: 'Enter account name' })
			}
		});

	permission.$on("select", /*selectPermission*/ ctx[16]);
	permission.$on("cancel", /*unselectChain*/ ctx[15]);

	return {
		c() {
			create_component(permission.$$.fragment);
		},
		m(target, anchor) {
			mount_component(permission, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const permission_changes = {};
			if (dirty & /*$client*/ 128) permission_changes.client = /*$client*/ ctx[7];
			if (dirty & /*$walletPlugin*/ 256) permission_changes.walletPlugin = /*$walletPlugin*/ ctx[8];
			if (dirty & /*$t*/ 8) permission_changes.title = /*$t*/ ctx[3]('login.enter.account', { default: 'Enter account name' });
			permission.$set(permission_changes);
		},
		i(local) {
			if (current) return;
			transition_in(permission.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(permission.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(permission, detaching);
		}
	};
}

// (164:8) <Transition direction={transitionDirection}>
function create_default_slot_1(ctx) {
	let blockchain;
	let current;

	blockchain = new Blockchain({
			props: {
				chains: /*$chains*/ ctx[6],
				title: /*$t*/ ctx[3]('login.select.blockchain', { default: 'Select a Blockchain' })
			}
		});

	blockchain.$on("select", /*selectChain*/ ctx[14]);
	blockchain.$on("cancel", /*unselectWallet*/ ctx[18]);

	return {
		c() {
			create_component(blockchain.$$.fragment);
		},
		m(target, anchor) {
			mount_component(blockchain, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blockchain_changes = {};
			if (dirty & /*$chains*/ 64) blockchain_changes.chains = /*$chains*/ ctx[6];
			if (dirty & /*$t*/ 8) blockchain_changes.title = /*$t*/ ctx[3]('login.select.blockchain', { default: 'Select a Blockchain' });
			blockchain.$set(blockchain_changes);
		},
		i(local) {
			if (current) return;
			transition_in(blockchain.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(blockchain.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(blockchain, detaching);
		}
	};
}

// (155:8) <Transition direction={transitionDirection}>
function create_default_slot$2(ctx) {
	let wallet;
	let current;

	wallet = new Wallet({
			props: {
				wallets: /*$loginContext*/ ctx[2].walletPlugins,
				title: /*$t*/ ctx[3]('login.select.wallet', { default: 'Select a Wallet' })
			}
		});

	wallet.$on("select", /*selectWallet*/ ctx[17]);
	wallet.$on("cancel", /*cancel*/ ctx[19]);

	return {
		c() {
			create_component(wallet.$$.fragment);
		},
		m(target, anchor) {
			mount_component(wallet, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const wallet_changes = {};
			if (dirty & /*$loginContext*/ 4) wallet_changes.wallets = /*$loginContext*/ ctx[2].walletPlugins;
			if (dirty & /*$t*/ 8) wallet_changes.title = /*$t*/ ctx[3]('login.select.wallet', { default: 'Select a Wallet' });
			wallet.$set(wallet_changes);
		},
		i(local) {
			if (current) return;
			transition_in(wallet.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(wallet.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(wallet, detaching);
		}
	};
}

function create_fragment$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$props*/ ctx[4] && /*$loginContext*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const right = 100;

function instance$6($$self, $$props, $$invalidate) {
	let $loginResponse;
	let $backAction;
	let $loginContext;
	let $t;
	let $props;
	let $step;
	let $chains;
	let $client;
	let $walletPlugin;
	component_subscribe($$self, loginResponse, $$value => $$invalidate(21, $loginResponse = $$value));
	component_subscribe($$self, backAction, $$value => $$invalidate(22, $backAction = $$value));
	component_subscribe($$self, loginContext, $$value => $$invalidate(2, $loginContext = $$value));
	component_subscribe($$self, props, $$value => $$invalidate(4, $props = $$value));
	const { t } = getContext('i18n');
	component_subscribe($$self, t, value => $$invalidate(3, $t = value));
	let completed = false;
	const dispatch = createEventDispatcher();
	var Steps;

	(function (Steps) {
		Steps["done"] = "done";
		Steps["enterPermission"] = "enterPermission";
		Steps["selectChain"] = "selectChain";
		Steps["selectPermission"] = "selectPermission";
		Steps["selectWallet"] = "selectWallet";
	})(Steps || (Steps = {}));

	const chain = derived([loginContext, loginResponse], ([$currentContext, $currentResponse]) => {
		if (!$currentContext || $currentResponse.chainId === undefined) {
			return undefined;
		}

		if ($currentContext.chain) {
			return $currentContext.chain;
		}

		return $currentContext.chains.find(c => c.id === $currentResponse.chainId);
	});

	const client = derived([chain, loginContext], ([$currentChain, $currentContext]) => {
		if (!$currentContext || $currentChain === undefined) {
			return undefined;
		}

		return $currentContext.getClient($currentChain);
	});

	component_subscribe($$self, client, value => $$invalidate(7, $client = value));

	const walletPlugin = derived([loginContext, loginResponse], ([$currentContext, $currentResponse]) => {
		if (!$currentContext || $currentResponse.walletPluginIndex === undefined) {
			return undefined;
		}

		return $currentContext.walletPlugins[$currentResponse.walletPluginIndex];
	});

	component_subscribe($$self, walletPlugin, value => $$invalidate(8, $walletPlugin = value));

	let chains = derived([loginContext, walletPlugin], ([$currentContext, $currentWalletPlugin]) => {
		if (!$currentContext || !$currentWalletPlugin) {
			return [];
		}

		// If the selected WalletPlugin has an array of supported chains, filter the list of chains
		if ($currentWalletPlugin.config.supportedChains) {
			return $currentContext.chains.filter(chain => {
				return !$currentWalletPlugin.config.supportedChains || $currentWalletPlugin.config.supportedChains.includes(String(chain.id));
			});
		}

		return $currentContext.chains;
	});

	component_subscribe($$self, chains, value => $$invalidate(6, $chains = value));

	const loginContextUnsubscribe = loginContext.subscribe(currentContext => {
		if (currentContext) {
			// If an appName is specified, set the title to it.
			set_store_value(
				props,
				$props.subtitle = $t('login.title-app', {
					appName: currentContext.appName,
					default: 'Login to {{appName}}'
				}),
				$props
			);

			// If a chain is specified, set it on the response
			if (currentContext.chain) {
				set_store_value(loginResponse, $loginResponse.chainId = currentContext.chain.id, $loginResponse);
			}

			// If only one chain is provided, default to it
			if (currentContext.chains.length === 1) {
				set_store_value(loginResponse, $loginResponse.chainId = currentContext.chains[0].id, $loginResponse);
			}

			// If a permissionLevel is defined, set it on the response
			if (currentContext.permissionLevel) {
				set_store_value(loginResponse, $loginResponse.permissionLevel = currentContext.permissionLevel, $loginResponse);
			}

			// If only one wallet is provided, default to it
			if (currentContext.walletPlugins.length === 1) {
				set_store_value(loginResponse, $loginResponse.walletPluginIndex = 0, $loginResponse);
			}
		}
	});

	onMount(() => {
		set_store_value(props, $props.title = $t('login.title', { default: 'Login' }), $props);
	});

	onDestroy(loginContextUnsubscribe);

	const step = derived([loginResponse, walletPlugin], ([$currentResponse, $currentWalletPlugin]) => {
		if (!$currentWalletPlugin) {
			return Steps.selectWallet;
		}

		const { requiresChainSelect, requiresPermissionEntry, requiresPermissionSelect, supportedChains } = $currentWalletPlugin.config;

		if (!$currentResponse.chainId && supportedChains && supportedChains.length === 1) {
			set_store_value(loginResponse, $loginResponse.chainId = supportedChains[0], $loginResponse);
			return Steps.selectPermission;
		} else if (!$currentResponse.chainId && $loginContext && $loginContext.chain) {
			set_store_value(loginResponse, $loginResponse.chainId = $loginContext?.chain.id, $loginResponse);
			return Steps.selectPermission;
		} else if (!$currentResponse.chainId && requiresChainSelect) {
			return Steps.selectChain;
		} else if (!$currentResponse.permissionLevel && requiresPermissionSelect) {
			return Steps.selectPermission;
		} else if (!$currentResponse.permissionLevel && requiresPermissionEntry) {
			return Steps.enterPermission;
		}

		// We have completed, return response to kit for the WalletPlugin to trigger
		complete();
	});

	component_subscribe($$self, step, value => $$invalidate(5, $step = value));
	let transitionDirection;
	const left = -100;

	const selectChain = e => {
		set_store_value(loginResponse, $loginResponse.chainId = e.detail, $loginResponse);
		set_store_value(backAction, $backAction = unselectChain, $backAction);
		$$invalidate(1, transitionDirection = right);
	};

	const unselectChain = () => {
		set_store_value(loginResponse, $loginResponse.chainId = undefined, $loginResponse);
		set_store_value(backAction, $backAction = unselectWallet, $backAction);
		$$invalidate(1, transitionDirection = left);
	};

	const selectPermission = e => {
		set_store_value(loginResponse, $loginResponse.permissionLevel = e.detail, $loginResponse);
		set_store_value(backAction, $backAction = undefined, $backAction);
		$$invalidate(1, transitionDirection = right);
	};

	const selectWallet = e => {
		set_store_value(backAction, $backAction = unselectWallet, $backAction);
		set_store_value(loginResponse, $loginResponse.walletPluginIndex = e.detail, $loginResponse);
		$$invalidate(1, transitionDirection = right);
	};

	const unselectWallet = () => {
		set_store_value(loginResponse, $loginResponse.walletPluginIndex = undefined, $loginResponse);
		set_store_value(backAction, $backAction = undefined, $backAction);
		$$invalidate(1, transitionDirection = left);
	};

	const complete = () => {
		if (!completed) {
			completed = true;
			dispatch('complete', $loginResponse);
			backAction.set(undefined);
		}
	};

	const cancel = () => {
		dispatch('cancel');
	};

	return [
		Steps,
		transitionDirection,
		$loginContext,
		$t,
		$props,
		$step,
		$chains,
		$client,
		$walletPlugin,
		t,
		client,
		walletPlugin,
		chains,
		step,
		selectChain,
		unselectChain,
		selectPermission,
		selectWallet,
		unselectWallet,
		cancel
	];
}

class Login extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
	}
}

/* src/ui/components/HeaderButton.svelte generated by Svelte v3.55.1 */

function add_css$3(target) {
	append_styles(target, "svelte-mttle8", "button.svelte-mttle8.svelte-mttle8{--button-size:46px;--button-size:var(--space-2xl);position:relative;isolation:isolate;background:var(--header-button-background);border:1px solid var(--header-button-outline);border:none;box-shadow:inset 0 0 0 1px var(--header-button-outline);border-radius:var(--border-radius-inner);cursor:pointer;width:var(--button-size);height:var(--button-size);display:grid;place-content:center;color:var(--header-text-color);transition:transform 80ms ease}button.svelte-mttle8.svelte-mttle8:active{transform:scale(95%);transform-origin:center}@media(hover: hover){button.svelte-mttle8:hover .background.svelte-mttle8{opacity:1}}.background.svelte-mttle8.svelte-mttle8{position:absolute;border-radius:var(--border-radius-inner);inset:0;opacity:0;z-index:-1;transition:opacity 80ms ease;background:var(--header-button-outline)}.visually-hidden.svelte-mttle8.svelte-mttle8{border:0;clip:rect(0 0 0 0);height:auto;margin:0;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap}");
}

function create_fragment$5(ctx) {
	let button;
	let span0;
	let t0;
	let icon_1;
	let t1;
	let span1;
	let t2;
	let current;
	let mounted;
	let dispose;
	icon_1 = new Icon({ props: { name: /*icon*/ ctx[1] } });

	return {
		c() {
			button = element("button");
			span0 = element("span");
			t0 = space();
			create_component(icon_1.$$.fragment);
			t1 = space();
			span1 = element("span");
			t2 = text(/*icon*/ ctx[1]);
			attr(span0, "class", "background svelte-mttle8");
			attr(span1, "class", "label visually-hidden svelte-mttle8");
			attr(button, "class", "svelte-mttle8");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, span0);
			append(button, t0);
			mount_component(icon_1, button, null);
			append(button, t1);
			append(button, span1);
			append(span1, t2);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", function () {
					if (is_function(/*onClick*/ ctx[0])) /*onClick*/ ctx[0].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			const icon_1_changes = {};
			if (dirty & /*icon*/ 2) icon_1_changes.name = /*icon*/ ctx[1];
			icon_1.$set(icon_1_changes);
			if (!current || dirty & /*icon*/ 2) set_data(t2, /*icon*/ ctx[1]);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			destroy_component(icon_1);
			mounted = false;
			dispose();
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { onClick } = $$props;
	let { icon } = $$props;

	$$self.$$set = $$props => {
		if ('onClick' in $$props) $$invalidate(0, onClick = $$props.onClick);
		if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
	};

	return [onClick, icon];
}

class HeaderButton extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { onClick: 0, icon: 1 }, add_css$3);
	}
}

/* src/ui/components/ThemeToggle.svelte generated by Svelte v3.55.1 */

function add_css$2(target) {
	append_styles(target, "svelte-1hx8qya", "button.svelte-1hx8qya{background:none;border:none;padding:0;cursor:pointer;flex:1;display:flex;flex-direction:column;justify-content:space-around;text-align:center}");
}

function create_fragment$4(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			button = element("button");
			if (default_slot) default_slot.c();
			attr(button, "class", "svelte-1hx8qya");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*toggleColorScheme*/ ctx[0]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	function toggleColorScheme() {
		colorScheme.update(current => current === 'light' ? 'dark' : 'light');
	}

	onMount(() => {
		// initialize the color scheme based on existing user preference otherwise system default
		if (window.matchMedia) {
			const mql = window.matchMedia('(prefers-color-scheme: dark)');
			colorScheme.set(getStoredColorScheme() ?? (mql.matches ? 'dark' : 'light'));

			mql.addEventListener('change', () => {
				colorScheme.set(mql.matches ? 'dark' : 'light');
			});
		}
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [toggleColorScheme, $$scope, slots];
}

class ThemeToggle extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {}, add_css$2);
	}
}

/* src/ui/components/Header.svelte generated by Svelte v3.55.1 */

function add_css$1(target) {
	append_styles(target, "svelte-j6z3r6", ".modal-header.svelte-j6z3r6.svelte-j6z3r6{box-sizing:border-box;min-height:var(--header-height);color:var(--header-text-color);background:var(--header-background-color);display:grid;grid-template-columns:1fr auto 1fr;gap:var(--space-s);padding:var(--space-m)}.modal-header.svelte-j6z3r6 .slot.svelte-j6z3r6{display:flex;align-items:center}.modal-header.svelte-j6z3r6 .center.svelte-j6z3r6{flex-direction:column;justify-content:space-around;text-align:center}.modal-header.svelte-j6z3r6 .right.svelte-j6z3r6{justify-content:flex-end}.modal-header.svelte-j6z3r6 .svelte-j6z3r6:is(h2, p){color:var(--header-text-color);margin:0;line-height:1.1em}.modal-header.svelte-j6z3r6 h2.svelte-j6z3r6{font-size:var(--fs-3);font-weight:700}.modal-header.svelte-j6z3r6 p.svelte-j6z3r6{font-size:var(--fs-0)}");
}

const get_right_slot_changes = dirty => ({});
const get_right_slot_context = ctx => ({});
const get_center_slot_changes = dirty => ({});
const get_center_slot_context = ctx => ({});
const get_left_slot_changes = dirty => ({});
const get_left_slot_context = ctx => ({});

// (14:12) {#if $backAction}
function create_if_block_1$1(ctx) {
	let div;
	let headerbutton;
	let div_transition;
	let current;

	headerbutton = new HeaderButton({
			props: {
				icon: "chevron-left",
				onClick: /*$backAction*/ ctx[2]
			}
		});

	return {
		c() {
			div = element("div");
			create_component(headerbutton.$$.fragment);
			attr(div, "class", "svelte-j6z3r6");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(headerbutton, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const headerbutton_changes = {};
			if (dirty & /*$backAction*/ 4) headerbutton_changes.onClick = /*$backAction*/ ctx[2];
			headerbutton.$set(headerbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in(headerbutton.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 100 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(headerbutton.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 100 }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(headerbutton);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

// (13:26)              
function fallback_block_2(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$backAction*/ ctx[2] && create_if_block_1$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*$backAction*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$backAction*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (25:16) {#if subtitle}
function create_if_block$1(ctx) {
	let p;
	let t;

	return {
		c() {
			p = element("p");
			t = text(/*subtitle*/ ctx[1]);
			attr(p, "class", "svelte-j6z3r6");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t);
		},
		p(ctx, dirty) {
			if (dirty & /*subtitle*/ 2) set_data(t, /*subtitle*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (23:12) <ThemeToggle>
function create_default_slot$1(ctx) {
	let h2;
	let t0;
	let t1;
	let if_block_anchor;
	let if_block = /*subtitle*/ ctx[1] && create_if_block$1(ctx);

	return {
		c() {
			h2 = element("h2");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(h2, "class", "svelte-j6z3r6");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t0);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data(t0, /*title*/ ctx[0]);

			if (/*subtitle*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (22:28)              
function fallback_block_1(ctx) {
	let themetoggle;
	let current;

	themetoggle = new ThemeToggle({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(themetoggle.$$.fragment);
		},
		m(target, anchor) {
			mount_component(themetoggle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const themetoggle_changes = {};

			if (dirty & /*$$scope, subtitle, title*/ 67) {
				themetoggle_changes.$$scope = { dirty, ctx };
			}

			themetoggle.$set(themetoggle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(themetoggle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(themetoggle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(themetoggle, detaching);
		}
	};
}

// (32:27)              
function fallback_block(ctx) {
	let headerbutton;
	let current;

	headerbutton = new HeaderButton({
			props: { icon: "close", onClick: /*func*/ ctx[5] }
		});

	return {
		c() {
			create_component(headerbutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(headerbutton, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(headerbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(headerbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(headerbutton, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let div3;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;
	let current;
	const left_slot_template = /*#slots*/ ctx[4].left;
	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[6], get_left_slot_context);
	const left_slot_or_fallback = left_slot || fallback_block_2(ctx);
	const center_slot_template = /*#slots*/ ctx[4].center;
	const center_slot = create_slot(center_slot_template, ctx, /*$$scope*/ ctx[6], get_center_slot_context);
	const center_slot_or_fallback = center_slot || fallback_block_1(ctx);
	const right_slot_template = /*#slots*/ ctx[4].right;
	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[6], get_right_slot_context);
	const right_slot_or_fallback = right_slot || fallback_block(ctx);

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			if (left_slot_or_fallback) left_slot_or_fallback.c();
			t0 = space();
			div1 = element("div");
			if (center_slot_or_fallback) center_slot_or_fallback.c();
			t1 = space();
			div2 = element("div");
			if (right_slot_or_fallback) right_slot_or_fallback.c();
			attr(div0, "class", "slot left svelte-j6z3r6");
			attr(div1, "class", "slot center svelte-j6z3r6");
			attr(div2, "class", "slot right svelte-j6z3r6");
			attr(div3, "class", "modal-header svelte-j6z3r6");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);

			if (left_slot_or_fallback) {
				left_slot_or_fallback.m(div0, null);
			}

			append(div3, t0);
			append(div3, div1);

			if (center_slot_or_fallback) {
				center_slot_or_fallback.m(div1, null);
			}

			append(div3, t1);
			append(div3, div2);

			if (right_slot_or_fallback) {
				right_slot_or_fallback.m(div2, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (left_slot) {
				if (left_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						left_slot,
						left_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(left_slot_template, /*$$scope*/ ctx[6], dirty, get_left_slot_changes),
						get_left_slot_context
					);
				}
			} else {
				if (left_slot_or_fallback && left_slot_or_fallback.p && (!current || dirty & /*$backAction*/ 4)) {
					left_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (center_slot) {
				if (center_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						center_slot,
						center_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(center_slot_template, /*$$scope*/ ctx[6], dirty, get_center_slot_changes),
						get_center_slot_context
					);
				}
			} else {
				if (center_slot_or_fallback && center_slot_or_fallback.p && (!current || dirty & /*subtitle, title*/ 3)) {
					center_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (right_slot) {
				if (right_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						right_slot,
						right_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(right_slot_template, /*$$scope*/ ctx[6], dirty, get_right_slot_changes),
						get_right_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(left_slot_or_fallback, local);
			transition_in(center_slot_or_fallback, local);
			transition_in(right_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(left_slot_or_fallback, local);
			transition_out(center_slot_or_fallback, local);
			transition_out(right_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			if (left_slot_or_fallback) left_slot_or_fallback.d(detaching);
			if (center_slot_or_fallback) center_slot_or_fallback.d(detaching);
			if (right_slot_or_fallback) right_slot_or_fallback.d(detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $backAction;
	component_subscribe($$self, backAction, $$value => $$invalidate(2, $backAction = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title } = $$props;
	let { subtitle } = $$props;
	const dispatch = createEventDispatcher();
	const func = () => dispatch('cancel');

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('subtitle' in $$props) $$invalidate(1, subtitle = $$props.subtitle);
		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [title, subtitle, $backAction, dispatch, slots, func, $$scope];
}

class Header extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { title: 0, subtitle: 1 }, add_css$1);
	}
}

/* src/ui/components/Modal.svelte generated by Svelte v3.55.1 */

function add_css(target) {
	append_styles(target, "svelte-ilturl", ":host dialog.svelte-ilturl,:root{color-scheme:light;--body-background-color:white;--body-text-color:var(--color-primary-700);--body-text-color-variant:var(--color-neutral-700);--header-background-color:var(--color-primary-700);--header-text-color:var(--color-primary-50);--header-button-background:var(--header-background-color);--header-button-outline:var(--color-primary-900);--button-text-color:var(--wharf-blue);--button-text-color-active:var(--wharf-blue);--button-outline-active:inset 0 0 0 2px var(--button-text-color);--button-primary-background:var(--color-secondary-200);--button-primary-background-hover:var(--color-secondary-200);--button-primary-background-active:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)),\n      var(--color-secondary-200);--button-primary-outline-hover:inset 0 0 0 1px #00000030,\n      inset 0 0 0 1px var(--color-secondary-200);--button-secondary-background:var(--color-custom-1);--button-secondary-background-hover:var(--color-custom-1);--button-secondary-background-active:var(--color-secondary-200);--button-secondary-outline-hover:inset 0 0 0 1px #00000020,\n      inset 0 0 0 1px var(--color-secondary-200);--button-outlined-background-active:var(--color-secondary-200);--button-outlined-outline:inset 0 0 0 1px var(--color-secondary-200);--button-outlined-outline-hover:inset 0 0 0 1px #00000020,\n      inset 0 0 0 1px var(--color-secondary-200);--input-placeholder-color:var(--color-neutral-500);--input-background-focus:var(--color-neutral-100);--input-border-color:#00000030;--input-border-color-hover:var(--color-custom-5);--input-border-color-focus:var(--wharf-blue);--qr-border-color:var(--seafoam-mint);--checkbox-stroke:var(--wharf-blue);--checkbox-fill:var(--reef-turquoise);--error-color:var(--color-error-1);--list-item-background-color-hover:var(--color-custom-9);--list-item-text-color-hover:var(--color-secondary-500);--list-divider-color:#00000010;--text-area-background:var(--swell-mist);--text-area-text-color:#242424}:host dialog[data-theme=dark].svelte-ilturl{color-scheme:dark;--body-background-color:var(--color-primary-700);--body-text-color:white;--body-text-color-variant:var(--color-neutral-300);--header-background-color:white;--header-text-color:var(--color-primary-700);--header-button-background:var(--header-background-color);--header-button-outline:var(--seafoam-mint);--button-text-color:var(--body-text-color);--button-text-color-active:var(--reef-turquoise);--button-outline-active:inset 0 0 0 2px var(--reef-turquoise);--button-primary-background:var(--color-secondary-500);--button-primary-background-hover:var(--color-secondary-500);--button-primary-background-active:var(--color-custom-2);--button-primary-outline-hover:inset 0 0 0 1px white;--button-secondary-background:var(--color-primary-800);--button-secondary-background-hover:var(--color-primary-800);--button-secondary-background-active:var(--color-primary-900);--button-secondary-outline-hover:inset 0 0 0 1px #ffffff30;--button-outlined-background-active:var(--color-primary-900);--button-outlined-outline:inset 0 0 0 1px #00000030;--button-outlined-outline-hover:inset 0 0 0 1px #ffffff30;--input-placeholder-color:#ffffff75;--input-background-focus:var(--color-custom-4);--input-border-color:#ffffff30;--input-border-color-hover:var(--color-custom-6);--input-border-color-focus:var(--reef-turquoise);--qr-border-color:rgba(0 0 0 / 0.2);--checkbox-stroke:var(--reef-turquoise);--checkbox-fill:var(--color-custom-3);--error-color:var(--color-error-3);--list-item-background-color-hover:var(--color-custom-8);--list-item-text-color-hover:var(--color-secondary-400);--list-divider-color:#ffffff10;--text-area-background:var(--color-primary-900);--text-area-text-color:#ffffff}@media(prefers-color-scheme: dark){:host dialog.svelte-ilturl,:root{color-scheme:dark;--body-background-color:var(--color-primary-700);--body-text-color:white;--body-text-color-variant:var(--color-neutral-300);--header-background-color:white;--header-text-color:var(--color-primary-700);--header-button-background:var(--header-background-color);--header-button-outline:var(--seafoam-mint);--button-text-color:var(--body-text-color);--button-text-color-active:var(--reef-turquoise);--button-outline-active:inset 0 0 0 2px var(--reef-turquoise);--button-primary-background:var(--color-secondary-500);--button-primary-background-hover:var(--color-secondary-500);--button-primary-background-active:var(--color-custom-2);--button-primary-outline-hover:inset 0 0 0 1px white;--button-secondary-background:var(--color-primary-800);--button-secondary-background-hover:var(--color-primary-800);--button-secondary-background-active:var(--color-primary-900);--button-secondary-outline-hover:inset 0 0 0 1px #ffffff30;--button-outlined-background-active:var(--color-primary-900);--button-outlined-outline:inset 0 0 0 1px #00000030;--button-outlined-outline-hover:inset 0 0 0 1px #ffffff30;--input-placeholder-color:#ffffff75;--input-background-focus:var(--color-custom-4);--input-border-color:#ffffff30;--input-border-color-hover:var(--color-custom-6);--input-border-color-focus:var(--reef-turquoise);--qr-border-color:rgba(0 0 0 / 0.2);--checkbox-stroke:var(--reef-turquoise);--checkbox-fill:var(--color-custom-3);--error-color:var(--color-error-3);--list-item-background-color-hover:var(--color-custom-8);--list-item-text-color-hover:var(--color-secondary-400);--list-divider-color:#ffffff10;--text-area-background:var(--color-primary-900);--text-area-text-color:#ffffff}:host dialog[data-theme=light].svelte-ilturl{color-scheme:light;--body-background-color:white;--body-text-color:var(--color-primary-700);--body-text-color-variant:var(--color-neutral-700);--header-background-color:var(--color-primary-700);--header-text-color:var(--color-primary-50);--header-button-background:var(--header-background-color);--header-button-outline:var(--color-primary-900);--button-text-color:var(--wharf-blue);--button-text-color-active:var(--wharf-blue);--button-outline-active:inset 0 0 0 2px var(--button-text-color);--button-primary-background:var(--color-secondary-200);--button-primary-background-hover:var(--color-secondary-200);--button-primary-background-active:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)),\n        var(--color-secondary-200);--button-primary-outline-hover:inset 0 0 0 1px #00000030,\n        inset 0 0 0 1px var(--color-secondary-200);--button-secondary-background:var(--color-custom-1);--button-secondary-background-hover:var(--color-custom-1);--button-secondary-background-active:var(--color-secondary-200);--button-secondary-outline-hover:inset 0 0 0 1px #00000020,\n        inset 0 0 0 1px var(--color-secondary-200);--button-outlined-background-active:var(--color-secondary-200);--button-outlined-outline:inset 0 0 0 1px var(--color-secondary-200);--button-outlined-outline-hover:inset 0 0 0 1px #00000020,\n        inset 0 0 0 1px var(--color-secondary-200);--input-placeholder-color:var(--color-neutral-500);--input-background-focus:var(--color-neutral-100);--input-border-color:#00000030;--input-border-color-hover:var(--color-custom-5);--input-border-color-focus:var(--wharf-blue);--qr-border-color:var(--seafoam-mint);--checkbox-stroke:var(--wharf-blue);--checkbox-fill:var(--reef-turquoise);--error-color:var(--color-error-1);--list-item-background-color-hover:var(--color-custom-9);--list-item-text-color-hover:var(--color-secondary-500);--list-divider-color:#00000010;--text-area-background:var(--swell-mist);--text-area-text-color:#242424}}:host dialog.svelte-ilturl,:root{--wharf-blue:var(--color-primary-700);--reef-turquoise:var(--color-secondary-300);--seafoam-mint:var(--color-secondary-200);--swell-mist:var(--color-accent-50);--color-primary-50:#f6f7f9;--color-primary-100:#ededf1;--color-primary-200:#d6d8e1;--color-primary-300:#b3b8c6;--color-primary-400:#8991a7;--color-primary-500:#6b738c;--color-primary-600:#565c73;--color-primary-700:#494e62;--color-primary-800:#3c4050;--color-primary-900:#363944;--color-secondary-50:#f1fcf9;--color-secondary-100:#cef9ed;--color-secondary-200:#b2f2e1;--color-secondary-300:#7be7ce;--color-secondary-400:#35ccae;--color-secondary-500:#1cb095;--color-secondary-600:#148d79;--color-secondary-700:#147163;--color-secondary-800:#155a51;--color-secondary-900:#164b43;--color-accent-50:#f4faf4;--color-accent-100:#e4f4e5;--color-accent-200:#cae8cc;--color-accent-300:#a1d4a3;--color-accent-400:#70b874;--color-accent-500:#4c9b51;--color-accent-600:#3a7f3e;--color-accent-700:#306534;--color-accent-800:#2a512d;--color-accent-900:#244326;--color-neutral-100:#f7f7f7;--color-neutral-200:#e3e3e3;--color-neutral-300:#c8c8c8;--color-neutral-400:#a4a4a4;--color-neutral-500:#818181;--color-neutral-600:#666666;--color-neutral-700:#515151;--color-neutral-800:#434343;--color-neutral-900:#383838;--color-custom-1:#f3f8f3;--color-custom-2:#415e60;--color-custom-3:#344b4d;--color-custom-4:#3d435a;--color-custom-5:#8ec2b4;--color-custom-6:#777b8b;--color-custom-7:#35ccae10;--color-custom-8:#575c6e;--color-custom-9:#f4f5f7;--color-error-1:#cd3939;--color-error-2:#ff5454;--color-error-3:#ffacac;font-family:system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif;--measure:35ch;--fs-0:12px;--fs-1:14px;--fs-2:16px;--fs-3:20px;--ratio:1.5;--space-4xs:calc(var(--space-3xs) / var(--ratio));--space-3xs:calc(var(--space-2xs) / var(--ratio));--space-2xs:calc(var(--space-xs) / var(--ratio));--space-xs:calc(var(--space-s) / var(--ratio));--space-s:calc(var(--space-m) / var(--ratio));--space-m:1rem;--space-l:calc(var(--space-m) * var(--ratio));--space-xl:calc(var(--space-l) * var(--ratio));--space-2xl:calc(var(--space-xl) * var(--ratio));--space-3xl:calc(var(--space-2xl) * var(--ratio));--space-4xl:calc(var(--space-3xl) * var(--ratio));--space-5xl:calc(var(--space-4xl) * var(--ratio));--space-6xl:calc(var(--space-5xl) * var(--ratio));--space-7xl:calc(var(--space-6xl) * var(--ratio));--space-8xl:calc(var(--space-7xl) * var(--ratio));--space-9xl:calc(var(--space-8xl) * var(--ratio));--border-radius-outer:24px;--border-radius-inner:12px;--header-height:var(--space-3xl)}.svelte-ilturl{box-sizing:border-box}.svelte-ilturl::selection{color:var(--wharf-blue);background-color:var(--seafoam-mint)}dialog.svelte-ilturl{--margin-top:var(--space-xl);font-family:system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif;margin-bottom:0;margin-top:var(--margin-top);margin-inline:auto;border:none !important;border-radius:var(--border-radius-outer);padding:0;width:min(var(--space-7xl), 100vw - var(--space-m));box-shadow:0px 4px 154px rgba(0, 0, 0, 0.35)}dialog.svelte-ilturl::backdrop{background:rgba(0, 0, 0, 0.75)}.modal-content.svelte-ilturl{--max-modal-content-height:calc(\n      100svh - var(--header-height) - var(--margin-top) - var(--margin-top)\n  );padding:var(--space-m);background-color:var(--body-background-color);overflow-y:scroll;max-height:var(--max-modal-content-height);scrollbar-gutter:stable both-edges;scrollbar-color:var(--header-background-color)}.modal-content.svelte-ilturl::-webkit-scrollbar{width:2px;background-color:var(--body-background-color)}.modal-content.svelte-ilturl::-webkit-scrollbar-thumb{background:var(--header-background-color)}");
}

function create_fragment$2(ctx) {
	let dialog_1;
	let header;
	let t;
	let div;
	let current;
	let mounted;
	let dispose;

	header = new Header({
			props: {
				title: /*$props*/ ctx[2].title,
				subtitle: /*$props*/ ctx[2].subtitle
			}
		});

	header.$on("cancel", /*cancelRequest*/ ctx[3]);
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			dialog_1 = element("dialog");
			create_component(header.$$.fragment);
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "modal-content svelte-ilturl");
			attr(dialog_1, "data-theme", /*$colorScheme*/ ctx[1]);
			attr(dialog_1, "class", "svelte-ilturl");
		},
		m(target, anchor) {
			insert(target, dialog_1, anchor);
			mount_component(header, dialog_1, null);
			append(dialog_1, t);
			append(dialog_1, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*dialog_1_binding*/ ctx[8](dialog_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(dialog_1, "click", /*backgroundClose*/ ctx[4], { passive: false, capture: true }),
					listen(dialog_1, "keyup", prevent_default(/*escapeClose*/ ctx[5]), { passive: false, capture: true })
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const header_changes = {};
			if (dirty & /*$props*/ 4) header_changes.title = /*$props*/ ctx[2].title;
			if (dirty & /*$props*/ 4) header_changes.subtitle = /*$props*/ ctx[2].subtitle;
			header.$set(header_changes);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$colorScheme*/ 2) {
				attr(dialog_1, "data-theme", /*$colorScheme*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(dialog_1);
			destroy_component(header);
			if (default_slot) default_slot.d(detaching);
			/*dialog_1_binding*/ ctx[8](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $cancelablePromises;
	let $colorScheme;
	let $props;
	component_subscribe($$self, cancelablePromises, $$value => $$invalidate(9, $cancelablePromises = $$value));
	component_subscribe($$self, colorScheme, $$value => $$invalidate(1, $colorScheme = $$value));
	component_subscribe($$self, props, $$value => $$invalidate(2, $props = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let dialog;

	// Control the dialog element display based on state.active
	const unsubscribe = active.subscribe(current => {
		if (dialog) {
			if (current && !dialog.open) {
				dialog.showModal();
			} else if (!current && dialog.open) {
				dialog.close();
				resetState();
			}
		}
	});

	onDestroy(unsubscribe);

	// Perform work required to cancel request
	function cancelRequest() {
		// Cancel any pending promises
		$cancelablePromises.map(f => f('Modal closed', true));

		// Update state to close the modal
		active.set(false);
	}

	// When background is clicked outside of modal, close
	function backgroundClose(event) {
		var rect = dialog.getBoundingClientRect();
		var isInDialog = rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;

		if (event.target === dialog && !isInDialog) {
			cancelRequest();
		}
	}

	// When escape keypress is captured, close
	function escapeClose(event) {
		if (event.key === 'Escape') {
			cancelRequest();
		}
	}

	function dialog_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dialog = $$value;
			$$invalidate(0, dialog);
		});
	}

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [
		dialog,
		$colorScheme,
		$props,
		cancelRequest,
		backgroundClose,
		escapeClose,
		$$scope,
		slots,
		dialog_1_binding
	];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {}, add_css);
	}
}

/* src/ui/Transact.svelte generated by Svelte v3.55.1 */

function create_fragment$1(ctx) {
	let p;

	let t_1_value = /*$t*/ ctx[0]('transact.processing', {
		default: 'Doing transact stuffs - cool animation!'
	}) + "";

	let t_1;

	return {
		c() {
			p = element("p");
			t_1 = text(t_1_value);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t_1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$t*/ 1 && t_1_value !== (t_1_value = /*$t*/ ctx[0]('transact.processing', {
				default: 'Doing transact stuffs - cool animation!'
			}) + "")) set_data(t_1, t_1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $t;
	const { t } = getContext('i18n');
	component_subscribe($$self, t, value => $$invalidate(0, $t = value));
	createEventDispatcher();

	return [$t, t];
}

class Transact extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
	}
}

/* src/ui/App.svelte generated by Svelte v3.55.1 */

function create_else_block(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Modal inactive";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (40:4) {#if $active}
function create_if_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_2, create_if_block_3, create_if_block_4];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*$errorDetails*/ ctx[2]) return 0;
		if (/*$prompt*/ ctx[0]) return 1;
		if (/*$router*/ ctx[3].path === 'login') return 2;
		if (/*$router*/ ctx[3].path === 'transact') return 3;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (47:46) 
function create_if_block_4(ctx) {
	let transact;
	let current;
	transact = new Transact({});
	transact.$on("cancel", /*cancel*/ ctx[4]);
	transact.$on("complete", /*complete*/ ctx[5]);

	return {
		c() {
			create_component(transact.$$.fragment);
		},
		m(target, anchor) {
			mount_component(transact, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(transact.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(transact.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(transact, detaching);
		}
	};
}

// (45:43) 
function create_if_block_3(ctx) {
	let login;
	let current;
	login = new Login({});
	login.$on("cancel", /*cancel*/ ctx[4]);
	login.$on("complete", /*complete*/ ctx[5]);

	return {
		c() {
			create_component(login.$$.fragment);
		},
		m(target, anchor) {
			mount_component(login, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(login.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(login.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(login, detaching);
		}
	};
}

// (43:26) 
function create_if_block_2(ctx) {
	let prompt_1;
	let current;
	prompt_1 = new Prompt({});
	prompt_1.$on("cancel", /*cancel*/ ctx[4]);
	prompt_1.$on("complete", /*complete*/ ctx[5]);

	return {
		c() {
			create_component(prompt_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(prompt_1, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(prompt_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(prompt_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(prompt_1, detaching);
		}
	};
}

// (41:8) {#if $errorDetails}
function create_if_block_1(ctx) {
	let error;
	let current;
	error = new Error$1({});
	error.$on("cancel", /*cancel*/ ctx[4]);
	error.$on("complete", /*complete*/ ctx[5]);

	return {
		c() {
			create_component(error.$$.fragment);
		},
		m(target, anchor) {
			mount_component(error, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(error, detaching);
		}
	};
}

// (39:0) <Modal>
function create_default_slot(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$active*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const modal_changes = {};

			if (dirty & /*$$scope, $errorDetails, $prompt, $router, $active*/ 271) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modal, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $prompt;
	let $loginPromise;
	let $active;
	let $errorDetails;
	let $router;
	component_subscribe($$self, prompt, $$value => $$invalidate(0, $prompt = $$value));
	component_subscribe($$self, loginPromise, $$value => $$invalidate(7, $loginPromise = $$value));
	component_subscribe($$self, active, $$value => $$invalidate(1, $active = $$value));
	component_subscribe($$self, errorDetails, $$value => $$invalidate(2, $errorDetails = $$value));
	component_subscribe($$self, router, $$value => $$invalidate(3, $router = $$value));
	let { i18n } = $$props;
	setContext('i18n', i18n);

	function cancel({ detail }) {
		// Reject any promises that are waiting for a response
		if ($loginPromise) {
			$loginPromise.reject(detail);
		}

		if ($prompt) {
			$prompt.reject(detail);
			prompt.reset();
		}

		router.back();
	}

	function complete({ detail }) {
		// Reject any promises that are waiting for a response
		if ($loginPromise) {
			$loginPromise.resolve(detail);
		}

		if ($prompt) {
			$prompt.resolve(detail);
			prompt.reset();
		}

		// Go back to previous path and remove it from the history
		router.back();
	}

	$$self.$$set = $$props => {
		if ('i18n' in $$props) $$invalidate(6, i18n = $$props.i18n);
	};

	return [$prompt, $active, $errorDetails, $router, cancel, complete, i18n];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { i18n: 6 });
	}
}

const defaultWebRendererOptions = {
    id: 'wharfkit-web-ui',
};
const getNavigatorLanguage = () => (navigator.languages && navigator.languages.length
    ? navigator.languages[0]
    : navigator.language || 'en').split('-')[0];
class WebRenderer extends AbstractUserInterface {
    constructor(options = defaultWebRendererOptions) {
        super();
        this.elementId = 'wharfkit-web-ui';
        // Add every cancelable promise to the list of cancelable promises
        this.addCancelablePromise = (promise) => cancelablePromises.update((current) => [...current, promise]);
        // Create the dialog element and its shadow root
        this.element = document.createElement('div');
        this.elementId = options.id || defaultWebRendererOptions.id;
        this.element.id = this.elementId;
        this.shadow = this.element.attachShadow({ mode: 'closed' });
        // Load translations for the current locale
        const lang = getNavigatorLanguage();
        this.i18n = makeLocalization();
        this.log(`Setting language to ${lang}`);
        this.i18n.loadTranslations(lang);
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            // Document is ready, append element
            this.appendDialogElement();
        }
        else {
            // Add listener to append to body
            document.addEventListener('DOMContentLoaded', () => this.appendDialogElement());
        }
    }
    appendDialogElement() {
        const existing = document.getElementById(this.elementId);
        if (!existing) {
            document.body.append(this.element);
            document.removeEventListener('DOMContentLoaded', () => this.appendDialogElement());
            new App({
                target: this.shadow,
                props: {
                    i18n: this.i18n,
                },
            });
        }
    }
    log(...args) {
        // eslint-disable-next-line no-console
        console.log('WebRenderer, LOG:', ...args);
    }
    login(context) {
        this.log('login', context);
        active.set(true);
        router.push('login');
        const promise = cancelable(new Promise((resolve, reject) => loginPromise.set({
            reject,
            resolve,
        })));
        this.addCancelablePromise(promise.cancel);
        loginContext.set(context);
        return promise;
    }
    async onError(error) {
        // Determine if this was a silent/cancelable error
        const isCancelable = error instanceof Canceled;
        const isSilent = isCancelable && error.silent === true;
        this.log('onError', {
            isCancelable,
            isSilent,
            error,
        });
        // If it was, don't display the error
        if (isSilent) {
            return;
        }
        // Make sure the dialog is active
        active.set(true);
        // Set the error state
        errorDetails.set(String(error));
        // Push the new path to the router
        router.push('error');
    }
    async onLogin() {
        this.log('onLogin');
        // Make sure the dialog is active
        active.set(true);
        // Set the title/subtitle to match the login state
        props.update((current) => ({
            ...current,
            title: this.i18n.t.get('login.title', { default: 'Login' }),
            subtitle: this.i18n.t.get('login.subtitle', { default: 'Please login to continue.' }),
        }));
        // Push the new path to the router
        router.push('login');
    }
    async onLoginComplete() {
        this.log('onLoginResult');
        // Close the dialog once the login completes
        active.set(false);
        // Reset all data in the state
        resetState();
    }
    async onTransact() {
        this.log('onTransact');
        // Make sure the dialog is active
        active.set(true);
        // Set the title/subtitle to match the transact state
        props.update((c) => ({
            ...c,
            title: this.i18n.t.get('transact.title', { default: 'Transact' }),
            subtitle: this.i18n.t.get('transact.subtitle', { default: ' ' }),
        }));
        // Push the new path to the router
        router.push('transact');
    }
    async onTransactComplete() {
        this.log('onTransactResult');
        // Reset all data in the state
        resetState();
        // Close the dialog once the transact completes
        active.set(false);
    }
    async onSign() {
        this.log('onSign');
        // Set the title/subtitle to match the transact state
        props.update((c) => ({
            ...c,
            subtitle: this.i18n.t.get('transact.signing', { default: 'Signing transaction' }),
        }));
    }
    async onSignComplete() {
        this.log('onSignComplete');
        // Set the title/subtitle to match the transact state
        props.update((c) => ({
            ...c,
            subtitle: this.i18n.t.get('transact.signed', { default: 'Transaction signed' }),
        }));
    }
    async onBroadcast() {
        this.log('onBroadcast');
        // Set the title/subtitle to match the transact state
        props.update((c) => ({
            ...c,
            subtitle: this.i18n.t.get('transact.broadcasting', {
                default: 'Broadcasting transaction',
            }),
        }));
    }
    async onBroadcastComplete() {
        this.log('onBroadcastComplete');
        // Set the title/subtitle to match the transact state
        props.update((c) => ({
            ...c,
            subtitle: this.i18n.t.get('transact.broadcasted', {
                default: 'Transaction broadcasted!',
            }),
        }));
    }
    prompt(args) {
        this.log('prompt', args);
        // Make sure the dialog is active
        active.set(true);
        // Push the new path to the router
        router.push('prompt');
        // Setup the promise to return to the session kit
        const promise = cancelable(new Promise((resolve, reject) => {
            prompt.set({
                args,
                resolve,
                reject,
            });
        }), (canceled) => {
            throw canceled;
        });
        // Save a copy of the promise to reference if canceled
        this.addCancelablePromise(promise.cancel);
        // Return the promise to the session kit
        return promise;
    }
    status(message) {
        // Make sure the dialog is active
        active.set(true);
        // Update the subtitle to match the message
        props.update((current) => ({
            ...current,
            subtitle: message,
        }));
    }
    // Map the UserInterface translate call to our i18n instance
    translate(key, options, namespace) {
        if (namespace) {
            return this.i18n.t.get(`${namespace}.${key}`, options);
        }
        return this.i18n.t.get(key, options);
    }
    addTranslations(translations) {
        this.i18n.addTranslations(translations);
    }
}
WebRenderer.version = '0.4.0'; // replaced by build script

export { WebRenderer, WebRenderer as default, defaultWebRendererOptions };
//# sourceMappingURL=web-renderer.m.js.map
